{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"pipda A framework for data piping in python Inspired by siuba , dfply , plydata and dplython , but with simple yet powerful APIs to mimic the dplyr and tidyr packages in python API | Change Log | Documentation Installation pip install -U pipda Usage Verbs A verb is pipeable (able to be called like data >> verb(...) ) A verb is dispatchable by the type of its first argument A verb evaluates other arguments using the first one A verb is passing down the context if not specified in the arguments import pandas as pd from pipda import ( register_verb , register_func , register_operator , evaluate_expr , Operator , Symbolic , Context ) f = Symbolic () df = pd . DataFrame ({ 'x' : [ 0 , 1 , 2 , 3 ], 'y' : [ 'zero' , 'one' , 'two' , 'three' ] }) df # x y # 0 0 zero # 1 1 one # 2 2 two # 3 3 three @register_verb ( pd . DataFrame ) def head ( data , n = 5 ): return data . head ( n ) df >> head ( 2 ) # x y # 0 0 zero # 1 1 one @register_verb ( pd . DataFrame , context = Context . EVAL ) def mutate ( data , ** kwargs ): data = data . copy () for key , val in kwargs . items (): data [ key ] = val return data df >> mutate ( z = 1 ) # x y z # 0 0 zero 1 # 1 1 one 1 # 2 2 two 1 # 3 3 three 1 df >> mutate ( z = f . x ) # x y z # 0 0 zero 0 # 1 1 one 1 # 2 2 two 2 # 3 3 three 3 Functions used as verb arguments # verb can be used as an argument passed to another verb # dep=True make `data` argument invisible while calling @register_verb ( pd . DataFrame , context = Context . EVAL , dep = True ) def if_else ( data , cond , true , false ): cond . loc [ cond . isin ([ True ]), ] = true cond . loc [ cond . isin ([ False ]), ] = false return cond # The function is then also a singledispatch generic function df >> mutate ( z = if_else ( f . x > 1 , 20 , 10 )) # x y z # 0 0 zero 10 # 1 1 one 10 # 2 2 two 20 # 3 3 three 20 # function without data argument @register_func def length ( strings ): return [ len ( s ) for s in strings ] df >> mutate ( z = length ( f . y )) # x y z # 0 0 zero 4 # 1 1 one 3 # 2 2 two 3 # 3 3 three 5 Context The context defines how a reference ( f.A , f['A'] , f.A.B is evaluated) @register_verb ( pd . DataFrame , context = Context . SELECT ) def select ( df , * columns ): return df [ list ( columns )] df >> select ( f . x , f . y ) # x y # 0 0 zero # 1 1 one # 2 2 two # 3 3 three How it works data %>% verb ( arg1 , ... , key1 = kwarg1 , ... ) The above is a typical dplyr / tidyr data piping syntax. The counterpart python syntax we expect is: data >> verb ( arg1 , ... , key1 = kwarg1 , ... ) To implement that, we need to defer the execution of the verb by turning it into a Verb object, which holds all information of the function to be executed later. The Verb object won't be executed until the data is piped in. It all thanks to the executing package to let us determine the ast nodes where the function is called. So that we are able to determine whether the function is called in a piping mode. If an argument is referring to a column of the data and the column will be involved in the later computation, the it also needs to be deferred. For example, with dplyr in R : data %>% mutate ( z = a ) is trying add a column named z with the data from column a . In python, we want to do the same with: data >> mutate ( z = f . a ) where f.a is a Reference object that carries the column information without fetching the data while python sees it immmediately. Here the trick is f . Like other packages, we introduced the Symbolic object, which will connect the parts in the argument and make the whole argument an Expression object. This object is holding the execution information, which we could use later when the piping is detected. Documentation https://pwwang.github.io/pipda/ See also datar for real-case usages.","title":"Home"},{"location":"#pipda","text":"A framework for data piping in python Inspired by siuba , dfply , plydata and dplython , but with simple yet powerful APIs to mimic the dplyr and tidyr packages in python API | Change Log | Documentation","title":"pipda"},{"location":"#installation","text":"pip install -U pipda","title":"Installation"},{"location":"#usage","text":"","title":"Usage"},{"location":"#verbs","text":"A verb is pipeable (able to be called like data >> verb(...) ) A verb is dispatchable by the type of its first argument A verb evaluates other arguments using the first one A verb is passing down the context if not specified in the arguments import pandas as pd from pipda import ( register_verb , register_func , register_operator , evaluate_expr , Operator , Symbolic , Context ) f = Symbolic () df = pd . DataFrame ({ 'x' : [ 0 , 1 , 2 , 3 ], 'y' : [ 'zero' , 'one' , 'two' , 'three' ] }) df # x y # 0 0 zero # 1 1 one # 2 2 two # 3 3 three @register_verb ( pd . DataFrame ) def head ( data , n = 5 ): return data . head ( n ) df >> head ( 2 ) # x y # 0 0 zero # 1 1 one @register_verb ( pd . DataFrame , context = Context . EVAL ) def mutate ( data , ** kwargs ): data = data . copy () for key , val in kwargs . items (): data [ key ] = val return data df >> mutate ( z = 1 ) # x y z # 0 0 zero 1 # 1 1 one 1 # 2 2 two 1 # 3 3 three 1 df >> mutate ( z = f . x ) # x y z # 0 0 zero 0 # 1 1 one 1 # 2 2 two 2 # 3 3 three 3","title":"Verbs"},{"location":"#functions-used-as-verb-arguments","text":"# verb can be used as an argument passed to another verb # dep=True make `data` argument invisible while calling @register_verb ( pd . DataFrame , context = Context . EVAL , dep = True ) def if_else ( data , cond , true , false ): cond . loc [ cond . isin ([ True ]), ] = true cond . loc [ cond . isin ([ False ]), ] = false return cond # The function is then also a singledispatch generic function df >> mutate ( z = if_else ( f . x > 1 , 20 , 10 )) # x y z # 0 0 zero 10 # 1 1 one 10 # 2 2 two 20 # 3 3 three 20 # function without data argument @register_func def length ( strings ): return [ len ( s ) for s in strings ] df >> mutate ( z = length ( f . y )) # x y z # 0 0 zero 4 # 1 1 one 3 # 2 2 two 3 # 3 3 three 5","title":"Functions used as verb arguments"},{"location":"#context","text":"The context defines how a reference ( f.A , f['A'] , f.A.B is evaluated) @register_verb ( pd . DataFrame , context = Context . SELECT ) def select ( df , * columns ): return df [ list ( columns )] df >> select ( f . x , f . y ) # x y # 0 0 zero # 1 1 one # 2 2 two # 3 3 three","title":"Context"},{"location":"#how-it-works","text":"data %>% verb ( arg1 , ... , key1 = kwarg1 , ... ) The above is a typical dplyr / tidyr data piping syntax. The counterpart python syntax we expect is: data >> verb ( arg1 , ... , key1 = kwarg1 , ... ) To implement that, we need to defer the execution of the verb by turning it into a Verb object, which holds all information of the function to be executed later. The Verb object won't be executed until the data is piped in. It all thanks to the executing package to let us determine the ast nodes where the function is called. So that we are able to determine whether the function is called in a piping mode. If an argument is referring to a column of the data and the column will be involved in the later computation, the it also needs to be deferred. For example, with dplyr in R : data %>% mutate ( z = a ) is trying add a column named z with the data from column a . In python, we want to do the same with: data >> mutate ( z = f . a ) where f.a is a Reference object that carries the column information without fetching the data while python sees it immmediately. Here the trick is f . Like other packages, we introduced the Symbolic object, which will connect the parts in the argument and make the whole argument an Expression object. This object is holding the execution information, which we could use later when the piping is detected.","title":"How it works"},{"location":"#documentation","text":"https://pwwang.github.io/pipda/ See also datar for real-case usages.","title":"Documentation"},{"location":"CHANGELOG/","text":"Change Log 0.13.1 \u2728 Add __array_function__ to Expression objects 0.13.0 \u2728 Add Dockerfile for codesandbox \u2b06\ufe0f Bump executing to ^2.0 \u2728 Support python 3.12 0.12.0 \u2b06\ufe0f Drop support for python3.7 0.11.1 \ud83d\udc77 Use newer actions \ud83d\udcdd Fix github action badegs \ud83e\ude79 Allow ast_fallback to be changed for verbs and functions 0.11.0 \ud83d\udca5 Simplify register_expr_array_func and rename it to register_array_ufunc 0.10.0 \ud83d\udca5 Refactor the registered borrowed from singledispatch \u2728 Allow pipeable and dispatchable functions (related: pwwang/datar#148) \ud83d\udca5 Change default ast_fallback to \"piping_warning\" for verbs \u2728 Allow to register multi-types at a time for dispatchable functions \u2728 Support backends \u2728 Allow register plain functions \u2705 Add level test for context \u2728 Make pipeable function work as a verb 0.9.0 \u2728 Allow __array_ufunc__ to be registered on Expression by register_expr_array_func 0.8.2 \u2728 Support other numpy ufunc methods 0.8.1 \u2728 Allow verb to be a placeholder (without any types registered) \u2705 Add test for npufuncs to be used in verbs 0.8.0 patch classes if they have piping operator method auto register numpy ufuncs pump executing to 1.1.1 to fix pwwang/datar#149 0.7.6 \ud83d\udc1b Fix numpy.ndarray as data argument for verbs \ud83d\ude9a Rename Expression.operator to Expression._pipda_operator 0.7.5 \u2728 Allow function meta infor to be overwritten 0.7.4 \ud83d\udc1b Allow numpy.ufuncs to be registered 0.7.3 \u2728 Make register an alias of register_verb 0.7.2 \u2728 Allow registering generic verbs 0.7.1 \ud83d\udc1b Fix VerbCall __str__ \u26a1\ufe0f Make Symbolic a singleton \ud83d\udc1b Allow general keyword arg for extra contexts \ud83e\uddf1 Always enable ast_fallback_arg \ud83d\udca5 Change the way verbs used as funcs \ud83e\ude79 Allow func passed directly to register_verb 0.7.0 \u267b\ufe0f Refactor to decrease complexity 0.6.0 \ud83d\udccc Pin versions of dependencies 0.5.9 \ud83d\ude91 Fix ImproperUseError of varname for Symbolic \ud83d\udcdd Pin deps for docs 0.5.8 \ud83d\udc1b Fix f >> verb(...) as argument of another verb in assume_all_piping mode 0.5.7 \ud83d\udc1b Fix f.x.mean() evaluation in all-piping mode 0.5.6 \ud83d\ude91 Fix context meta not recovered when error 0.5.5 \ud83d\ude91 Fix stringify slice when it appears as ref of a ReferenceItem object 0.5.4 \u2728 Add with_meta() for context to evaluate expr temporarily 0.5.3 \ud83d\ude91 Fix operator func lookup for Operator \ud83e\ude79 Don't stringify the Symbolic object f . a # previously: \"f.a\", now: \"a\" f [ 'a' ] # previously: \"f[a]\", now: \"a\" f . a [ 'b' ] # previously: \"f.a[b]\", now: \"a[b]\" mean ( f . a ) # previously: \"mean(f.a)\", now: \"mean(a)\" f . a + 1 # previously: \"f.a + 1\", now: \"a + 1\" 0.5.2 Add level argument to context.getitem()/getattr() so that the expression level can be used in evaluation; Add eval_symbolic() to context to allow evaluate Symbolic objects in different ways. 0.5.1 Remove abstract property name from contexts ( name is no longer a required property to subclass ContextBase ) Allow meta data of context to be passed down from pipda import Symbolic , register_func , register_verb , evaluate_expr from pipda.context import Context , ContextEval f = Symbolic () @register_func ( None , context = Context . SELECT ) def wrapper ( x ): return x @register_func ( None , context = Context . EVAL ) def times_meta ( x , _context = None ): return x * _context . meta [ \"val\" ] @register_verb ( dict , context = ContextEval ({ \"val\" : 10 })) def add ( x , y ): return x [ \"a\" ] + y # metadata passed down to times_meta { \"a\" : 1 } >> add ( wrapper ( use_meta ( f [ \"a\" ]))) # 12 0.5.0 Stringify Expression objects reasonably f . a -> \"f.a\" f [ 'a' ] -> \"f[a]\" mean ( f . a ) -> \"mean(f.a)\" f . a + 1 -> \"f.a + 1\" Deprecate DirectRefAttr and DirectRefItem . Use ref._pipda_level instead. f -> f . _pipda_level == 0 f . a -> f . _pipda_level == 1 f . a . b -> f . _pipda_level == 2 Household Use flake8 instead of pylint for linting. 0.4.5 Add CallingEnvs.REGULAR 0.4.4 Add options and options_context . Move warn_astnode_failure to options Add assume_all_piping mode 0.4.3 Avoid raising exception for varname() to get the name of Symbolic object. 0.4.2 Make Function property private thus accessiable to getattr() (otherwise returns an Expression object) Give better repr for Function when func is an Expression object. 0.4.1 Fix getattr() failure for operator-connected expressions (pwwang/datar#38) 0.4.0 Improve calling rules for verbs, data functions and non-data functions Remove evaluate_args() and evaluate_kwargs() , use evaluate_expr() instead 0.3.0 Added: Add a better regular calling strategy and warn for ambiguity Support #11 Breaking changes: Rename register_piping_sign to register_piping 0.2.9 Avoid func of Function object to be re-evaluated (fixing datar#14) 0.2.8 Add is_direct argument to context getitem/getattr to tell if the reference is a direct reference. 0.2.7 Allow Reference objects to be functions (callable) 0.2.6 Let Symbolic.__getitem__ return DirectRefItem instead of ReferenceItem 0.2.5 Allow custom evaluation for objects in verb arguments. 0.2.4 Allow extra attributes to be registered together with funcs/verbs 0.1.6 Allow to register different context for different types Allow verb to be used as argument of a verb","title":"Change log"},{"location":"CHANGELOG/#change-log","text":"","title":"Change Log"},{"location":"CHANGELOG/#0131","text":"\u2728 Add __array_function__ to Expression objects","title":"0.13.1"},{"location":"CHANGELOG/#0130","text":"\u2728 Add Dockerfile for codesandbox \u2b06\ufe0f Bump executing to ^2.0 \u2728 Support python 3.12","title":"0.13.0"},{"location":"CHANGELOG/#0120","text":"\u2b06\ufe0f Drop support for python3.7","title":"0.12.0"},{"location":"CHANGELOG/#0111","text":"\ud83d\udc77 Use newer actions \ud83d\udcdd Fix github action badegs \ud83e\ude79 Allow ast_fallback to be changed for verbs and functions","title":"0.11.1"},{"location":"CHANGELOG/#0110","text":"\ud83d\udca5 Simplify register_expr_array_func and rename it to register_array_ufunc","title":"0.11.0"},{"location":"CHANGELOG/#0100","text":"\ud83d\udca5 Refactor the registered borrowed from singledispatch \u2728 Allow pipeable and dispatchable functions (related: pwwang/datar#148) \ud83d\udca5 Change default ast_fallback to \"piping_warning\" for verbs \u2728 Allow to register multi-types at a time for dispatchable functions \u2728 Support backends \u2728 Allow register plain functions \u2705 Add level test for context \u2728 Make pipeable function work as a verb","title":"0.10.0"},{"location":"CHANGELOG/#090","text":"\u2728 Allow __array_ufunc__ to be registered on Expression by register_expr_array_func","title":"0.9.0"},{"location":"CHANGELOG/#082","text":"\u2728 Support other numpy ufunc methods","title":"0.8.2"},{"location":"CHANGELOG/#081","text":"\u2728 Allow verb to be a placeholder (without any types registered) \u2705 Add test for npufuncs to be used in verbs","title":"0.8.1"},{"location":"CHANGELOG/#080","text":"patch classes if they have piping operator method auto register numpy ufuncs pump executing to 1.1.1 to fix pwwang/datar#149","title":"0.8.0"},{"location":"CHANGELOG/#076","text":"\ud83d\udc1b Fix numpy.ndarray as data argument for verbs \ud83d\ude9a Rename Expression.operator to Expression._pipda_operator","title":"0.7.6"},{"location":"CHANGELOG/#075","text":"\u2728 Allow function meta infor to be overwritten","title":"0.7.5"},{"location":"CHANGELOG/#074","text":"\ud83d\udc1b Allow numpy.ufuncs to be registered","title":"0.7.4"},{"location":"CHANGELOG/#073","text":"\u2728 Make register an alias of register_verb","title":"0.7.3"},{"location":"CHANGELOG/#072","text":"\u2728 Allow registering generic verbs","title":"0.7.2"},{"location":"CHANGELOG/#071","text":"\ud83d\udc1b Fix VerbCall __str__ \u26a1\ufe0f Make Symbolic a singleton \ud83d\udc1b Allow general keyword arg for extra contexts \ud83e\uddf1 Always enable ast_fallback_arg \ud83d\udca5 Change the way verbs used as funcs \ud83e\ude79 Allow func passed directly to register_verb","title":"0.7.1"},{"location":"CHANGELOG/#070","text":"\u267b\ufe0f Refactor to decrease complexity","title":"0.7.0"},{"location":"CHANGELOG/#060","text":"\ud83d\udccc Pin versions of dependencies","title":"0.6.0"},{"location":"CHANGELOG/#059","text":"\ud83d\ude91 Fix ImproperUseError of varname for Symbolic \ud83d\udcdd Pin deps for docs","title":"0.5.9"},{"location":"CHANGELOG/#058","text":"\ud83d\udc1b Fix f >> verb(...) as argument of another verb in assume_all_piping mode","title":"0.5.8"},{"location":"CHANGELOG/#057","text":"\ud83d\udc1b Fix f.x.mean() evaluation in all-piping mode","title":"0.5.7"},{"location":"CHANGELOG/#056","text":"\ud83d\ude91 Fix context meta not recovered when error","title":"0.5.6"},{"location":"CHANGELOG/#055","text":"\ud83d\ude91 Fix stringify slice when it appears as ref of a ReferenceItem object","title":"0.5.5"},{"location":"CHANGELOG/#054","text":"\u2728 Add with_meta() for context to evaluate expr temporarily","title":"0.5.4"},{"location":"CHANGELOG/#053","text":"\ud83d\ude91 Fix operator func lookup for Operator \ud83e\ude79 Don't stringify the Symbolic object f . a # previously: \"f.a\", now: \"a\" f [ 'a' ] # previously: \"f[a]\", now: \"a\" f . a [ 'b' ] # previously: \"f.a[b]\", now: \"a[b]\" mean ( f . a ) # previously: \"mean(f.a)\", now: \"mean(a)\" f . a + 1 # previously: \"f.a + 1\", now: \"a + 1\"","title":"0.5.3"},{"location":"CHANGELOG/#052","text":"Add level argument to context.getitem()/getattr() so that the expression level can be used in evaluation; Add eval_symbolic() to context to allow evaluate Symbolic objects in different ways.","title":"0.5.2"},{"location":"CHANGELOG/#051","text":"Remove abstract property name from contexts ( name is no longer a required property to subclass ContextBase ) Allow meta data of context to be passed down from pipda import Symbolic , register_func , register_verb , evaluate_expr from pipda.context import Context , ContextEval f = Symbolic () @register_func ( None , context = Context . SELECT ) def wrapper ( x ): return x @register_func ( None , context = Context . EVAL ) def times_meta ( x , _context = None ): return x * _context . meta [ \"val\" ] @register_verb ( dict , context = ContextEval ({ \"val\" : 10 })) def add ( x , y ): return x [ \"a\" ] + y # metadata passed down to times_meta { \"a\" : 1 } >> add ( wrapper ( use_meta ( f [ \"a\" ]))) # 12","title":"0.5.1"},{"location":"CHANGELOG/#050","text":"Stringify Expression objects reasonably f . a -> \"f.a\" f [ 'a' ] -> \"f[a]\" mean ( f . a ) -> \"mean(f.a)\" f . a + 1 -> \"f.a + 1\" Deprecate DirectRefAttr and DirectRefItem . Use ref._pipda_level instead. f -> f . _pipda_level == 0 f . a -> f . _pipda_level == 1 f . a . b -> f . _pipda_level == 2 Household Use flake8 instead of pylint for linting.","title":"0.5.0"},{"location":"CHANGELOG/#045","text":"Add CallingEnvs.REGULAR","title":"0.4.5"},{"location":"CHANGELOG/#044","text":"Add options and options_context . Move warn_astnode_failure to options Add assume_all_piping mode","title":"0.4.4"},{"location":"CHANGELOG/#043","text":"Avoid raising exception for varname() to get the name of Symbolic object.","title":"0.4.3"},{"location":"CHANGELOG/#042","text":"Make Function property private thus accessiable to getattr() (otherwise returns an Expression object) Give better repr for Function when func is an Expression object.","title":"0.4.2"},{"location":"CHANGELOG/#041","text":"Fix getattr() failure for operator-connected expressions (pwwang/datar#38)","title":"0.4.1"},{"location":"CHANGELOG/#040","text":"Improve calling rules for verbs, data functions and non-data functions Remove evaluate_args() and evaluate_kwargs() , use evaluate_expr() instead","title":"0.4.0"},{"location":"CHANGELOG/#030","text":"Added: Add a better regular calling strategy and warn for ambiguity Support #11 Breaking changes: Rename register_piping_sign to register_piping","title":"0.3.0"},{"location":"CHANGELOG/#029","text":"Avoid func of Function object to be re-evaluated (fixing datar#14)","title":"0.2.9"},{"location":"CHANGELOG/#028","text":"Add is_direct argument to context getitem/getattr to tell if the reference is a direct reference.","title":"0.2.8"},{"location":"CHANGELOG/#027","text":"Allow Reference objects to be functions (callable)","title":"0.2.7"},{"location":"CHANGELOG/#026","text":"Let Symbolic.__getitem__ return DirectRefItem instead of ReferenceItem","title":"0.2.6"},{"location":"CHANGELOG/#025","text":"Allow custom evaluation for objects in verb arguments.","title":"0.2.5"},{"location":"CHANGELOG/#024","text":"Allow extra attributes to be registered together with funcs/verbs","title":"0.2.4"},{"location":"CHANGELOG/#016","text":"Allow to register different context for different types Allow verb to be used as argument of a verb","title":"0.1.6"},{"location":"backends/","text":"Backends Verbs and registered functions can be implemented for different backends. The dispatching is generally distinguishing different implementations. However, sometimes we want to use different implementations for the same type. In this case, we can use the backend argument to register the function for a specific backend. For example, we want to implement a function rep for different backends. from pipda import register_func @register_func ( dispatchable = \"args\" ) def rep ( x , y ): raise NotImplementedError @rep . register ( cls = int , backend = \"python\" ) def _ ( x , y ): return [ x ] * y @rep . register ( cls = int , backend = \"numpy\" ) def _ ( x , y ): import numpy as np return np . repeat ( x , y ) # Later registered backend has higher priority # But a warning will be shown since we have two implementations for int rep ( 1 , 3 ) # np.array([1, 1, 1]) # Use __backend argument to specify the backend rep ( 1 , 3 , __backend = \"python\" ) # [1, 1, 1] To eliminate the warning, we can also use the favored implementation for a backend: from pipda import register_func @register_func ( dispatchable = \"args\" ) def rep ( x , y ): raise NotImplementedError @rep . register ( cls = int , backend = \"python\" ) def _ ( x , y ): return [ x ] * y @rep . register ( cls = int , backend = \"numpy\" , favored = True ) def _ ( x , y ): import numpy as np return np . repeat ( x , y ) # Later registered backend has higher priority # No warnings anymore rep ( 1 , 3 ) # np.array([1, 1, 1]) rep ( 1 , 3 , __backend = \"python\" ) # [1, 1, 1] Verbs apply the same rule for backends.","title":"Backends"},{"location":"backends/#backends","text":"Verbs and registered functions can be implemented for different backends. The dispatching is generally distinguishing different implementations. However, sometimes we want to use different implementations for the same type. In this case, we can use the backend argument to register the function for a specific backend. For example, we want to implement a function rep for different backends. from pipda import register_func @register_func ( dispatchable = \"args\" ) def rep ( x , y ): raise NotImplementedError @rep . register ( cls = int , backend = \"python\" ) def _ ( x , y ): return [ x ] * y @rep . register ( cls = int , backend = \"numpy\" ) def _ ( x , y ): import numpy as np return np . repeat ( x , y ) # Later registered backend has higher priority # But a warning will be shown since we have two implementations for int rep ( 1 , 3 ) # np.array([1, 1, 1]) # Use __backend argument to specify the backend rep ( 1 , 3 , __backend = \"python\" ) # [1, 1, 1] To eliminate the warning, we can also use the favored implementation for a backend: from pipda import register_func @register_func ( dispatchable = \"args\" ) def rep ( x , y ): raise NotImplementedError @rep . register ( cls = int , backend = \"python\" ) def _ ( x , y ): return [ x ] * y @rep . register ( cls = int , backend = \"numpy\" , favored = True ) def _ ( x , y ): import numpy as np return np . repeat ( x , y ) # Later registered backend has higher priority # No warnings anymore rep ( 1 , 3 ) # np.array([1, 1, 1]) rep ( 1 , 3 , __backend = \"python\" ) # [1, 1, 1] Verbs apply the same rule for backends.","title":"Backends"},{"location":"contexts/","text":"Context The context defines how a reference ( f.A , f['A'] , f.A.B is evaluated) Context.EVAL This context evaluates the references directly. For example, if data is {\"a\": 1} , f[\"a\"] will be evaluted into 1 . from pipda import register_verb , Context @register_verb ( dict , context = Context . EVAL ) def mutate ( data , ** kwargs ): data = data . copy () data . update ( kwargs ) return data { \"a\" : 1 } >> mutate ( b = f [ \"a\" ] * 2 ) # {\"a\": 1, \"b\": 2} Context.SELECT This context evaluates the references into the attribute names or subscripts themselves. This, for f.key works sometimes as a shortcut for \"key\" . @register_verb ( dict , context = Context . SELECT ) def select ( data , * keys ): return { key : val for key , val in data . items () if key in keys } { \"a\" : 1 , \"b\" : 2 } >> select ( f . a ) # {\"a\": 1} Context.PENDING This remains expressions un-evaluated so that they get passed into the function and evaluted later inside the function. from pipda import Context , register_verb , evaluate_expr @register_verb ( dict , context = Context . PENDING ) def mutate ( data , ** kwargs ): # kwargs is holding expressions kwargs = evaluate_expr ( kwargs , data , Context . EVAL ) data = data . copy () data . update ( kwargs ) return data { \"a\" : 1 } >> mutate ( b = f [ \"a\" ] * 2 ) # {\"a\": 1, \"b\": 2} Customizing a context You can write your own context by subclassing ContextBase . Overwrite the following methods to define the behaviors: getattr : How to evaluate f.A getitem : How to evaluate f[\"A\"] ref (property): How to evaluate x in f[x] from pipda import Context , ContextBase , register_verb class MyContext ( ContextBase ): def getattr ( self , parent , ref , level ): # f.A -> level 1 # f.A.B -> level 2 return parent [ ref ] def getitem ( self , parent , ref , level ): return ref @register_verb ( dict , context = MyContext ()) def subset_and_update ( data , * cols , ** kwargs ): data = { key : val for key , val in data . items () if key in cols } data . update ( kwargs ) return data { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } >> subset_and_update ( f . a , f . b , a = f . c ) # {\"a\": 3, \"b\": 2} Note Note that for Context.PENDING , we need to subclass context.ContextPending to keep expressions unevaluated. Contexts for keyword arguments We can set extra contexts for keyword arguments. @register_verb ( dict , context = Context . EVAL , kw_context = { \"cols\" : Context . SELECT }, ) def subset_and_update ( data , * , cols , ** kwargs ): data = { key : val for key , val in data . items () if key in cols } data . update ( kwargs ) return data { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } >> subset_and_update ( f . a , f . b , a = f . c ) # {\"a\": 3, \"b\": 2} Note By default, the context is None , the expressions, including FunctionCall and VerbCall objects, will be awaiting next coming avaiable context to evaluate Note When registering another type(s) for a verb, contexts and extra contexts are inherited for the first ones that registered with register_verb Tip Each implementation for the registered verbs or functions can have its own contexts. Specify them when registering the implementations. < verb >. register ( ... , context =... , kw_context =... ) < func >. register ( ... , context =... , kw_context =... )","title":"Contexts"},{"location":"contexts/#context","text":"The context defines how a reference ( f.A , f['A'] , f.A.B is evaluated)","title":"Context"},{"location":"contexts/#contexteval","text":"This context evaluates the references directly. For example, if data is {\"a\": 1} , f[\"a\"] will be evaluted into 1 . from pipda import register_verb , Context @register_verb ( dict , context = Context . EVAL ) def mutate ( data , ** kwargs ): data = data . copy () data . update ( kwargs ) return data { \"a\" : 1 } >> mutate ( b = f [ \"a\" ] * 2 ) # {\"a\": 1, \"b\": 2}","title":"Context.EVAL"},{"location":"contexts/#contextselect","text":"This context evaluates the references into the attribute names or subscripts themselves. This, for f.key works sometimes as a shortcut for \"key\" . @register_verb ( dict , context = Context . SELECT ) def select ( data , * keys ): return { key : val for key , val in data . items () if key in keys } { \"a\" : 1 , \"b\" : 2 } >> select ( f . a ) # {\"a\": 1}","title":"Context.SELECT"},{"location":"contexts/#contextpending","text":"This remains expressions un-evaluated so that they get passed into the function and evaluted later inside the function. from pipda import Context , register_verb , evaluate_expr @register_verb ( dict , context = Context . PENDING ) def mutate ( data , ** kwargs ): # kwargs is holding expressions kwargs = evaluate_expr ( kwargs , data , Context . EVAL ) data = data . copy () data . update ( kwargs ) return data { \"a\" : 1 } >> mutate ( b = f [ \"a\" ] * 2 ) # {\"a\": 1, \"b\": 2}","title":"Context.PENDING"},{"location":"contexts/#customizing-a-context","text":"You can write your own context by subclassing ContextBase . Overwrite the following methods to define the behaviors: getattr : How to evaluate f.A getitem : How to evaluate f[\"A\"] ref (property): How to evaluate x in f[x] from pipda import Context , ContextBase , register_verb class MyContext ( ContextBase ): def getattr ( self , parent , ref , level ): # f.A -> level 1 # f.A.B -> level 2 return parent [ ref ] def getitem ( self , parent , ref , level ): return ref @register_verb ( dict , context = MyContext ()) def subset_and_update ( data , * cols , ** kwargs ): data = { key : val for key , val in data . items () if key in cols } data . update ( kwargs ) return data { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } >> subset_and_update ( f . a , f . b , a = f . c ) # {\"a\": 3, \"b\": 2} Note Note that for Context.PENDING , we need to subclass context.ContextPending to keep expressions unevaluated.","title":"Customizing a context"},{"location":"contexts/#contexts-for-keyword-arguments","text":"We can set extra contexts for keyword arguments. @register_verb ( dict , context = Context . EVAL , kw_context = { \"cols\" : Context . SELECT }, ) def subset_and_update ( data , * , cols , ** kwargs ): data = { key : val for key , val in data . items () if key in cols } data . update ( kwargs ) return data { \"a\" : 1 , \"b\" : 2 , \"c\" : 3 } >> subset_and_update ( f . a , f . b , a = f . c ) # {\"a\": 3, \"b\": 2} Note By default, the context is None , the expressions, including FunctionCall and VerbCall objects, will be awaiting next coming avaiable context to evaluate Note When registering another type(s) for a verb, contexts and extra contexts are inherited for the first ones that registered with register_verb Tip Each implementation for the registered verbs or functions can have its own contexts. Specify them when registering the implementations. < verb >. register ( ... , context =... , kw_context =... ) < func >. register ( ... , context =... , kw_context =... )","title":"Contexts for keyword arguments"},{"location":"expressions/","text":"Expressions In order to achieve the piping, we need to delay the execution of python expressions. pipda turns python expressions, including operators, function calls, getattr, getitem, etc into Expression objects. So they can await the data to be piped in and get evaluated. A Symbolic object is a root expression that is supposed to be evaluated as the data itself. An expression can be evaluated manually by expr._pipda_eval(data, context) . f = Symbolic () f . _pipda_eval ( 1 ) # 1 A Symbolic can derive into other Expression objects: f = Symbolic () f . a # ReferenceAttr object f [ \"a\" ] # ReferenceItem object f . a () # FunctionCall object f . a + f . b # OperatorCall object numpy ufuncs on Expression objects import numpy as np from pipda import Symbolic f = Symbolic () x = np . sqrt ( f ) x . _pipda_eval ( 4 ) # 2.0 Register your own __array_ufunc__ import numpy as np from pipda import Symbolic , register_array_ufunc @register_array_ufunc def my_ufunc ( ufunc , x , * args , ** kwargs ): return ufunc ( x , * args , ** kwargs ) * 2 f = Symbolic () x = np . sqrt ( f ) x . _pipda_eval ( 4 ) # 4.0","title":"Expressions"},{"location":"expressions/#expressions","text":"In order to achieve the piping, we need to delay the execution of python expressions. pipda turns python expressions, including operators, function calls, getattr, getitem, etc into Expression objects. So they can await the data to be piped in and get evaluated. A Symbolic object is a root expression that is supposed to be evaluated as the data itself. An expression can be evaluated manually by expr._pipda_eval(data, context) . f = Symbolic () f . _pipda_eval ( 1 ) # 1 A Symbolic can derive into other Expression objects: f = Symbolic () f . a # ReferenceAttr object f [ \"a\" ] # ReferenceItem object f . a () # FunctionCall object f . a + f . b # OperatorCall object","title":"Expressions"},{"location":"expressions/#numpy-ufuncs-on-expression-objects","text":"import numpy as np from pipda import Symbolic f = Symbolic () x = np . sqrt ( f ) x . _pipda_eval ( 4 ) # 2.0","title":"numpy ufuncs on Expression objects"},{"location":"expressions/#register-your-own-__array_ufunc__","text":"import numpy as np from pipda import Symbolic , register_array_ufunc @register_array_ufunc def my_ufunc ( ufunc , x , * args , ** kwargs ): return ufunc ( x , * args , ** kwargs ) * 2 f = Symbolic () x = np . sqrt ( f ) x . _pipda_eval ( 4 ) # 4.0","title":"Register your own __array_ufunc__"},{"location":"functions/","text":"Functions For functions, we mean that the registered functions, rather than the python plain functions. Function calls are used as verb arguments, but they can be used independently as well, if no expressions is passed to the function. Functions share some features with verbs, such as that they could be pipeable and dispatchable as well. But they have a lot of differences as well. The biggest ones are that a function: doesn't use the type of the first argument only to dispatch doesn't pass the context down doesn't evaluate other arguments using the first one (unless specified) but the data passed to the call from a verb, unless a data is piped in. Register a function To register a function, use register_func function/decorator. Here are the arguments: func: The generic function. If None (not provided), this function will return a decorator. cls: The default type to register for _default backend if TypeHolder, it is a generic function, and not counted as a real implementation. For plain or non-dispatchable functions, specify a different type than TypeHolder to indicate the func is a real implementation. plain: If True, the function will be registered as a plain function, which means it will be called without any evaluation of the arguments. It doesn't support dispatchable and pipeable. name: and qualname: and doc: and module: The meta information about the function to overwrite func 's or when it's not available from func ast_fallback: What's the supposed way to call the func when AST node detection fails. piping - Suppose this func is called like data >> func(...) normal - Suppose this func is called like func(data, ...) piping_warning - Suppose piping call, but show a warning normal_warning - Suppose normal call, but show a warning raise - Raise an error dispatchable: If True, the function will be registered as a dispatchable function, which means it will be dispatched using the types of positional arguments. dispatch_args: Which arguments to use for dispatching. \"first\" - Use the first argument \"args\" - Use all positional arguments \"kwargs\" - Use all keyword arguments \"all\" - Use all arguments pipeable: If True, the function will work like a verb when a data is piping in. If dispatchable, the first argument will be used to dispatch the implementation. The rest of the arguments will be evaluated using the data from the first argument. context: The context used to evaluate the rest arguments using the first argument only when the function is pipeable and the data is piping in. kw_context: The context used to evaluate the keyword arguments Plain functions One could register functions as plain functions, which means they will be called without any evaluation of the arguments. It doesn't support dispatchable and pipeable. The reason to allow plain functions is that we could have multiple implementations for different backends for plain functions. See Backends for more details. Dispatchable functions One could register functions as dispatchable functions, which means they will be dispatched using the type of the first argument, the types of positional arguments, the types of of the keyword arguments, or the types of all arguments. The types are determined after the arguments are evaluated. One could specify the context for evaluation of the arguments. See Contexts for more details. If not specified, the context passed down from the verb will be used. One could also specify the context for the function and kw_context for the keyword arguments. Once an implementation is found, the later arguments will be ignored. If no implementation is found, the default implementation (that raises NotImplementedError ) will be used. Dispatching by the type of the first argument Using the type of the first argument: from pipda import register_func @register_func ( cls = int , dispatchable = \"first\" ) def rep ( x , y ): return x + y @rep . register ( str ) def _ ( x , y ): return x * y rep ( 1 , 2 ) # 3 rep ( \"a\" , 3 ) # \"aaa\" Using the types of the positional arguments: from pipda import register_func @register_func ( cls = int , dispatchable = \"args\" ) def rep ( x , y ): return x * y @rep . register ( str ) def _ ( x , y ): return x + str ( y ) rep ( 1 , 2 ) # 2 rep ( \"a\" , 3 ) # \"a3\" # Type of 2nd argument used rep ([ 1 ], 2 ) # [1, 1] Using the types of the keyword arguments: from pipda import register_func @register_func ( cls = str , dispatchable = \"kwargs\" ) def rep ( x , y ): return x + y @rep . register ( int ) def _ ( x , y ): return x * y rep ( \"1\" , y = 2 ) # 11 rep ( \"1\" , y = \"2\" ) # \"12\" Using the types of all arguments: from pipda import register_func @register_func ( cls = str , dispatchable = \"kwargs\" ) def rep ( x , y ): return x + str ( y ) @rep . register ( int ) def _ ( x , y ): return x * y # Dispatched eagerly rep ( \"1\" , y = 2 ) # \"12\" rep ( \"1\" , y = \"2\" ) # \"12\" Pipeable functions One could register functions as pipeable functions, which means they will work like a verb when a data is piping in. If dispatchable, the first argument will be used to dispatch the implementation. The rest of the arguments will be evaluated using the data from the first argument. from pipda import register_func @register_func ( cls = int , pipeable = True ) def rep ( x , y ): return x + y 1 >> rep ( 2 ) # 3","title":"Functions"},{"location":"functions/#functions","text":"For functions, we mean that the registered functions, rather than the python plain functions. Function calls are used as verb arguments, but they can be used independently as well, if no expressions is passed to the function. Functions share some features with verbs, such as that they could be pipeable and dispatchable as well. But they have a lot of differences as well. The biggest ones are that a function: doesn't use the type of the first argument only to dispatch doesn't pass the context down doesn't evaluate other arguments using the first one (unless specified) but the data passed to the call from a verb, unless a data is piped in.","title":"Functions"},{"location":"functions/#register-a-function","text":"To register a function, use register_func function/decorator. Here are the arguments: func: The generic function. If None (not provided), this function will return a decorator. cls: The default type to register for _default backend if TypeHolder, it is a generic function, and not counted as a real implementation. For plain or non-dispatchable functions, specify a different type than TypeHolder to indicate the func is a real implementation. plain: If True, the function will be registered as a plain function, which means it will be called without any evaluation of the arguments. It doesn't support dispatchable and pipeable. name: and qualname: and doc: and module: The meta information about the function to overwrite func 's or when it's not available from func ast_fallback: What's the supposed way to call the func when AST node detection fails. piping - Suppose this func is called like data >> func(...) normal - Suppose this func is called like func(data, ...) piping_warning - Suppose piping call, but show a warning normal_warning - Suppose normal call, but show a warning raise - Raise an error dispatchable: If True, the function will be registered as a dispatchable function, which means it will be dispatched using the types of positional arguments. dispatch_args: Which arguments to use for dispatching. \"first\" - Use the first argument \"args\" - Use all positional arguments \"kwargs\" - Use all keyword arguments \"all\" - Use all arguments pipeable: If True, the function will work like a verb when a data is piping in. If dispatchable, the first argument will be used to dispatch the implementation. The rest of the arguments will be evaluated using the data from the first argument. context: The context used to evaluate the rest arguments using the first argument only when the function is pipeable and the data is piping in. kw_context: The context used to evaluate the keyword arguments","title":"Register a function"},{"location":"functions/#plain-functions","text":"One could register functions as plain functions, which means they will be called without any evaluation of the arguments. It doesn't support dispatchable and pipeable. The reason to allow plain functions is that we could have multiple implementations for different backends for plain functions. See Backends for more details.","title":"Plain functions"},{"location":"functions/#dispatchable-functions","text":"One could register functions as dispatchable functions, which means they will be dispatched using the type of the first argument, the types of positional arguments, the types of of the keyword arguments, or the types of all arguments. The types are determined after the arguments are evaluated. One could specify the context for evaluation of the arguments. See Contexts for more details. If not specified, the context passed down from the verb will be used. One could also specify the context for the function and kw_context for the keyword arguments. Once an implementation is found, the later arguments will be ignored. If no implementation is found, the default implementation (that raises NotImplementedError ) will be used.","title":"Dispatchable functions"},{"location":"functions/#dispatching-by-the-type-of-the-first-argument","text":"Using the type of the first argument: from pipda import register_func @register_func ( cls = int , dispatchable = \"first\" ) def rep ( x , y ): return x + y @rep . register ( str ) def _ ( x , y ): return x * y rep ( 1 , 2 ) # 3 rep ( \"a\" , 3 ) # \"aaa\" Using the types of the positional arguments: from pipda import register_func @register_func ( cls = int , dispatchable = \"args\" ) def rep ( x , y ): return x * y @rep . register ( str ) def _ ( x , y ): return x + str ( y ) rep ( 1 , 2 ) # 2 rep ( \"a\" , 3 ) # \"a3\" # Type of 2nd argument used rep ([ 1 ], 2 ) # [1, 1] Using the types of the keyword arguments: from pipda import register_func @register_func ( cls = str , dispatchable = \"kwargs\" ) def rep ( x , y ): return x + y @rep . register ( int ) def _ ( x , y ): return x * y rep ( \"1\" , y = 2 ) # 11 rep ( \"1\" , y = \"2\" ) # \"12\" Using the types of all arguments: from pipda import register_func @register_func ( cls = str , dispatchable = \"kwargs\" ) def rep ( x , y ): return x + str ( y ) @rep . register ( int ) def _ ( x , y ): return x * y # Dispatched eagerly rep ( \"1\" , y = 2 ) # \"12\" rep ( \"1\" , y = \"2\" ) # \"12\"","title":"Dispatching by the type of the first argument"},{"location":"functions/#pipeable-functions","text":"One could register functions as pipeable functions, which means they will work like a verb when a data is piping in. If dispatchable, the first argument will be used to dispatch the implementation. The rest of the arguments will be evaluated using the data from the first argument. from pipda import register_func @register_func ( cls = int , pipeable = True ) def rep ( x , y ): return x + y 1 >> rep ( 2 ) # 3","title":"Pipeable functions"},{"location":"operators/","text":"Operators Operators can be redefined with pipda . By default, the operators are from the builtin library operator . The \"right\" versions (e.g. radd , rsub , etc) are derived from the builtin ones by swapping the operands. You can define you own operators: from pipda import Symbolic , Operator , register_operator f = Symbolic () @register_operator class MyOperator ( Operator ): def add ( self , x , y ): return x * y def invert ( self , x ): return - x expr = f [ \"x\" ] + 10 assert str ( expr ) == \"x + 10\" assert expr . _pipda_eval ({ \"x\" : 3 }, Context . EVAL ) == 30 expr = 10 * f [ \"x\" ] assert str ( expr ) == \"10 * x\" assert expr . _pipda_eval ({ \"x\" : 2 }, Context . EVAL ) == 20 expr = ~ f [ \"x\" ] assert str ( expr ) == \"~x\" assert expr . _pipda_eval ({ \"x\" : 2 }, Context . EVAL ) == - 2 register_operator ( Operator ) expr = ~ f [ \"x\" ] assert str ( expr ) == \"~x\" assert expr . _pipda_eval ({ \"x\" : 2 }, Context . EVAL ) == - 3 # ~2","title":"Operators"},{"location":"operators/#operators","text":"Operators can be redefined with pipda . By default, the operators are from the builtin library operator . The \"right\" versions (e.g. radd , rsub , etc) are derived from the builtin ones by swapping the operands. You can define you own operators: from pipda import Symbolic , Operator , register_operator f = Symbolic () @register_operator class MyOperator ( Operator ): def add ( self , x , y ): return x * y def invert ( self , x ): return - x expr = f [ \"x\" ] + 10 assert str ( expr ) == \"x + 10\" assert expr . _pipda_eval ({ \"x\" : 3 }, Context . EVAL ) == 30 expr = 10 * f [ \"x\" ] assert str ( expr ) == \"10 * x\" assert expr . _pipda_eval ({ \"x\" : 2 }, Context . EVAL ) == 20 expr = ~ f [ \"x\" ] assert str ( expr ) == \"~x\" assert expr . _pipda_eval ({ \"x\" : 2 }, Context . EVAL ) == - 2 register_operator ( Operator ) expr = ~ f [ \"x\" ] assert str ( expr ) == \"~x\" assert expr . _pipda_eval ({ \"x\" : 2 }, Context . EVAL ) == - 3 # ~2","title":"Operators"},{"location":"piping/","text":"Piping How it works to detect piping data %>% verb ( arg1 , ... , key1 = kwarg1 , ... ) The above is a typical dplyr/tidyr data piping syntax. The counterpart python syntax we expect is: data >> verb ( arg1 , ... , key1 = kwarg1 , ... ) To implement that, we need to defer the execution of the verb by turning it into a Verb object, which holds all information of the function to be executed later. The Verb object won't be executed until the data is piped in. It all thanks to the executing package to let us determine the ast nodes where the function is called. So that we are able to determine whether the function is called in a piping mode. If an argument is referring to a column of the data and the column will be involved in the later computation, the it also needs to be deferred. For example, with dplyr in R: data %>% mutate ( z = a ) is trying add a column named z with the data from column a. In python, we want to do the same with: data >> mutate ( z = f . a ) where f.a is a Reference object that carries the column information without fetching the data while python sees it immmediately. Here the trick is f. Like other packages, we introduced the Symbolic object, which will connect the parts in the argument and make the whole argument an Expression object. This object is holding the execution information, which we could use later when the piping is detected. Fallbacks when AST node detection fails pipda detects the AST node for the verb calling. If it is next to a piping operator (defaults to >> , could be changed by register_piping() ), then it is compiled into a VerbCall object, awaiting data to pipe in to evalute. We call this the piping mode. Otherwise, it is treated a as normal function call, where the data should be passed directly. This is the normal mode. However, the AST node is not always available. pipda relies on executing to detect the node. There are situations AST nodes can not be detected. One of the biggest reasons is that the source code is not avaiable/compromised at runtime. For example, pytest 's assert statement, raw python REPL, etc. We can set up a fallback mode when we fail to determine the AST node. piping : fallback to piping mode if AST node not avaiable normal : fallback to normal node if AST node not avaiable piping_warning : fallback to piping mode if AST node not avaiable and given a warning normal_warning (default): fallback to normal mode if AST node not avaiable and given a warning raise : Raise an error We can also pass one of the above values to __ast_fallback when we call the verb. @register_verb ( int , ast_fallback = \"normal\" ) def add ( x , y ): return x + y @register_verb ( int , ast_fallback = \"piping\" ) def sub ( x , y ): return x - y @register_verb ( int ) def mul ( x , y ): return x * y # In an environment AST node cannot be detected add ( 1 , 2 ) # 3, ok 1 >> add ( 2 ) # TypeError, argument y missing 2 >> sub ( 1 ) # 1, ok sub ( 2 , 1 ) # TypeError, argument y missing mul ( 1 , 2 , __ast_fallback = \"normal\" ) # 3 1 >> mul ( 2 , __ast_fallback = \"piping\" ) # 3 # Change the fallback add . ast_fallback = \"piping\" 1 >> add ( 2 ) # 3, ok add ( 1 , 2 ) # VerbCall object Using a different operator for piping By default, >> is used for piping. We can also use other operators, including \">>\", \"|\", \"//\", \"@\", \"%\", \"&\" and \"^\". from pipda import register_piping , register_verb register_piping ( \"|\" ) @register_verb ( int ) def add ( x , y ): return x + y 1 | add ( 2 ) # 3","title":"Piping"},{"location":"piping/#piping","text":"","title":"Piping"},{"location":"piping/#how-it-works-to-detect-piping","text":"data %>% verb ( arg1 , ... , key1 = kwarg1 , ... ) The above is a typical dplyr/tidyr data piping syntax. The counterpart python syntax we expect is: data >> verb ( arg1 , ... , key1 = kwarg1 , ... ) To implement that, we need to defer the execution of the verb by turning it into a Verb object, which holds all information of the function to be executed later. The Verb object won't be executed until the data is piped in. It all thanks to the executing package to let us determine the ast nodes where the function is called. So that we are able to determine whether the function is called in a piping mode. If an argument is referring to a column of the data and the column will be involved in the later computation, the it also needs to be deferred. For example, with dplyr in R: data %>% mutate ( z = a ) is trying add a column named z with the data from column a. In python, we want to do the same with: data >> mutate ( z = f . a ) where f.a is a Reference object that carries the column information without fetching the data while python sees it immmediately. Here the trick is f. Like other packages, we introduced the Symbolic object, which will connect the parts in the argument and make the whole argument an Expression object. This object is holding the execution information, which we could use later when the piping is detected.","title":"How it works to detect piping"},{"location":"piping/#fallbacks-when-ast-node-detection-fails","text":"pipda detects the AST node for the verb calling. If it is next to a piping operator (defaults to >> , could be changed by register_piping() ), then it is compiled into a VerbCall object, awaiting data to pipe in to evalute. We call this the piping mode. Otherwise, it is treated a as normal function call, where the data should be passed directly. This is the normal mode. However, the AST node is not always available. pipda relies on executing to detect the node. There are situations AST nodes can not be detected. One of the biggest reasons is that the source code is not avaiable/compromised at runtime. For example, pytest 's assert statement, raw python REPL, etc. We can set up a fallback mode when we fail to determine the AST node. piping : fallback to piping mode if AST node not avaiable normal : fallback to normal node if AST node not avaiable piping_warning : fallback to piping mode if AST node not avaiable and given a warning normal_warning (default): fallback to normal mode if AST node not avaiable and given a warning raise : Raise an error We can also pass one of the above values to __ast_fallback when we call the verb. @register_verb ( int , ast_fallback = \"normal\" ) def add ( x , y ): return x + y @register_verb ( int , ast_fallback = \"piping\" ) def sub ( x , y ): return x - y @register_verb ( int ) def mul ( x , y ): return x * y # In an environment AST node cannot be detected add ( 1 , 2 ) # 3, ok 1 >> add ( 2 ) # TypeError, argument y missing 2 >> sub ( 1 ) # 1, ok sub ( 2 , 1 ) # TypeError, argument y missing mul ( 1 , 2 , __ast_fallback = \"normal\" ) # 3 1 >> mul ( 2 , __ast_fallback = \"piping\" ) # 3 # Change the fallback add . ast_fallback = \"piping\" 1 >> add ( 2 ) # 3, ok add ( 1 , 2 ) # VerbCall object","title":"Fallbacks when AST node detection fails"},{"location":"piping/#using-a-different-operator-for-piping","text":"By default, >> is used for piping. We can also use other operators, including \">>\", \"|\", \"//\", \"@\", \"%\", \"&\" and \"^\". from pipda import register_piping , register_verb register_piping ( \"|\" ) @register_verb ( int ) def add ( x , y ): return x + y 1 | add ( 2 ) # 3","title":"Using a different operator for piping"},{"location":"verbs/","text":"Verbs Registering a verb You can use register_verb to register a verb. Here are the arguments of register_verb : cls: The default type to register for _default backend if TypeHolder, it is a generic function, and not counted as a real implementation. func: The function works as a verb. If None (not provided), this function will return a decorator. context: The context to evaluate the arguments kw_context: The context to evaluate the keyword arguments name: and qualname: and doc: and module: The meta information about the function to overwrite func 's or when it's not available from func dependent: Whether the verb is dependent. >>> @register_verb ( context = Context . EVAL , dependent = True ) >>> def length ( data ): >>> return len ( data ) >>> # with dependent=True >>> # length() -> VerbCall, waiting for data to evaluate >>> # with dependent=False >>> # length() -> TypeError, argument data is missing ast_fallback: What's the supposed way to call the verb when AST node detection fails. piping - Suppose this verb is called like data >> verb(...) normal - Suppose this verb is called like verb(data, ...) piping_warning - Suppose piping call, but show a warning normal_warning - Suppose normal call, but show a warning raise - Raise an error Verbs are pipeable from pipda import register_verb @register_verb ( int ) def increment ( data ): return data + 1 1 >> increment () # 2 # You can also call it normally increment ( 1 ) # 2 More about pipeable, see Piping . Verbs are dispatchable Like single-dispatched functions, verbs are dispatchable by the type of its first argument. from pipda import register_verb @register_verb ( int ) def increment ( data ): return data + 1 @increment . register ( str ) def _increment ( data ): return data + '1' 1 >> increment () # 2 '1' >> increment () # '11' What if a verb is not registered for a type? It will be dispatched to default generic function, which raises a NotImplementedError . [] >> increment () # NotImplementedError If you want change the default behavior, you can register a generic function by yourself, using a type holder. from pipda import register_verb from pipda.utils import TypeHolder @register_verb ( TypeHolder ) def increment ( data ): return data + 1 1.1 >> increment () # 2.1 Verbs evaluate other arguments using the first one as data from pipda import register_verb , Context , Symbolic f = Symbolic () @register_verb ( list , context = Context . EVAL ) def add ( data , other ): \"\"\"Add other to each element of data\"\"\" return [ d + other for d in data ] [ 1 , 2 , 3 ] >> add ( 1 ) # [2, 3, 4] # Using the first element of data [ 1 , 2 , 3 ] >> add ( f [ 0 ]) # [2, 3, 4] More about contexts, see Contexts . Verbs pass down the context if not specified in the arguments from pipda import register_func , register_verb , Context , Symbolic f = Symbolic () @register_func () # no context specified def double ( data ): return data * 2 @register_verb ( list , context = Context . EVAL ) def add ( data , other ): return [ d + other for d in data ] [ 1 , 2 , 3 ] >> add ( double ( f [ 0 ])) # [3, 4, 5] Dependent verbs Dependent verbs are functions can be used in another verb without passing the data argument. It can also work as a normal verb. from pipda import register_verb , Context , Symbolic f = Symbolic () @register_verb ( list , dependent = True ) def times ( data , n ): \"\"\"Times each element of data with n\"\"\" return [ d * n for d in data ] @register_verb ( list , context = Context . EVAL ) def add ( data , other ): \"\"\"Add other to each element of data\"\"\" return [ d + other for d in data ] # times 2 to each element and add the first element to all elementss # Note that we don't pass the first argument to times [ 1 , 2 , 3 ] >> add ( times ( 2 )[ 0 ]) # [3, 4, 5] # When called directly: times ( 2 ) # VerbCall object times ([ 1 , 2 , 3 ], 2 ) # VerbCall object # But when a data piped in, it is evaluated [ 1 , 2 , 3 ] >> times ( 2 ) # [2, 4, 6]","title":"Verbs"},{"location":"verbs/#verbs","text":"","title":"Verbs"},{"location":"verbs/#registering-a-verb","text":"You can use register_verb to register a verb. Here are the arguments of register_verb : cls: The default type to register for _default backend if TypeHolder, it is a generic function, and not counted as a real implementation. func: The function works as a verb. If None (not provided), this function will return a decorator. context: The context to evaluate the arguments kw_context: The context to evaluate the keyword arguments name: and qualname: and doc: and module: The meta information about the function to overwrite func 's or when it's not available from func dependent: Whether the verb is dependent. >>> @register_verb ( context = Context . EVAL , dependent = True ) >>> def length ( data ): >>> return len ( data ) >>> # with dependent=True >>> # length() -> VerbCall, waiting for data to evaluate >>> # with dependent=False >>> # length() -> TypeError, argument data is missing ast_fallback: What's the supposed way to call the verb when AST node detection fails. piping - Suppose this verb is called like data >> verb(...) normal - Suppose this verb is called like verb(data, ...) piping_warning - Suppose piping call, but show a warning normal_warning - Suppose normal call, but show a warning raise - Raise an error","title":"Registering a verb"},{"location":"verbs/#verbs-are-pipeable","text":"from pipda import register_verb @register_verb ( int ) def increment ( data ): return data + 1 1 >> increment () # 2 # You can also call it normally increment ( 1 ) # 2 More about pipeable, see Piping .","title":"Verbs are pipeable"},{"location":"verbs/#verbs-are-dispatchable","text":"Like single-dispatched functions, verbs are dispatchable by the type of its first argument. from pipda import register_verb @register_verb ( int ) def increment ( data ): return data + 1 @increment . register ( str ) def _increment ( data ): return data + '1' 1 >> increment () # 2 '1' >> increment () # '11' What if a verb is not registered for a type? It will be dispatched to default generic function, which raises a NotImplementedError . [] >> increment () # NotImplementedError If you want change the default behavior, you can register a generic function by yourself, using a type holder. from pipda import register_verb from pipda.utils import TypeHolder @register_verb ( TypeHolder ) def increment ( data ): return data + 1 1.1 >> increment () # 2.1","title":"Verbs are dispatchable"},{"location":"verbs/#verbs-evaluate-other-arguments-using-the-first-one-as-data","text":"from pipda import register_verb , Context , Symbolic f = Symbolic () @register_verb ( list , context = Context . EVAL ) def add ( data , other ): \"\"\"Add other to each element of data\"\"\" return [ d + other for d in data ] [ 1 , 2 , 3 ] >> add ( 1 ) # [2, 3, 4] # Using the first element of data [ 1 , 2 , 3 ] >> add ( f [ 0 ]) # [2, 3, 4] More about contexts, see Contexts .","title":"Verbs evaluate other arguments using the first one as data"},{"location":"verbs/#verbs-pass-down-the-context-if-not-specified-in-the-arguments","text":"from pipda import register_func , register_verb , Context , Symbolic f = Symbolic () @register_func () # no context specified def double ( data ): return data * 2 @register_verb ( list , context = Context . EVAL ) def add ( data , other ): return [ d + other for d in data ] [ 1 , 2 , 3 ] >> add ( double ( f [ 0 ])) # [3, 4, 5]","title":"Verbs pass down the context if not specified in the arguments"},{"location":"verbs/#dependent-verbs","text":"Dependent verbs are functions can be used in another verb without passing the data argument. It can also work as a normal verb. from pipda import register_verb , Context , Symbolic f = Symbolic () @register_verb ( list , dependent = True ) def times ( data , n ): \"\"\"Times each element of data with n\"\"\" return [ d * n for d in data ] @register_verb ( list , context = Context . EVAL ) def add ( data , other ): \"\"\"Add other to each element of data\"\"\" return [ d + other for d in data ] # times 2 to each element and add the first element to all elementss # Note that we don't pass the first argument to times [ 1 , 2 , 3 ] >> add ( times ( 2 )[ 0 ]) # [3, 4, 5] # When called directly: times ( 2 ) # VerbCall object times ([ 1 , 2 , 3 ], 2 ) # VerbCall object # But when a data piped in, it is evaluated [ 1 , 2 , 3 ] >> times ( 2 ) # [2, 4, 6]","title":"Dependent verbs"},{"location":"api/pipda.context/","text":"module pipda . context </> Provides the context to evaluate f.A and f['A'] By default, 1. in the context of select, both f.A and f['A'] return 'A' 2. in the context of evaluation, f.A returns data.A and f['A'] returns data['A'] 3. when it is pending, you will need to evaluate args and kwargs yourself. Classes ContextError \u2014 Any errors related to contexts </> ContextBase ( ) \u2014 The context abstract class, defining howthe Reference objects are evaluated </> ContextSelect \u2014 Context used in a select context </> ContextEval \u2014 Context used in a data-evaluation context </> ContextPending \u2014 Pending context, don't evaluate the expression,awaiting next avaiable context </> Context \u2014 Context to solve f.A and f['A'] </> class pipda.context . ContextError ( ) </> Bases Exception BaseException Any errors related to contexts abstract class pipda.context . ContextBase ( ) </> The context abstract class, defining howthe Reference objects are evaluated getattr defines how f.A is evaluated. Note that f.A.B will always be evaluated as getattr(f.A, 'B') getitem defines how f[item] is evaluated. Note that the item here is an evaluated value defined by getref . ref here defines how the reference/item in f.item is evaluated. Since we could do f[f.A] . Attributes ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , level ) (any) \u2014 Defines how f.A is evaluated </> getitem ( parent , ref , level ) (any) \u2014 Defines how f[item] is evaluated </> abstract method getattr ( parent , ref , level ) \u2192 any </> Defines how f.A is evaluated abstract method getitem ( parent , ref , level ) \u2192 any </> Defines how f[item] is evaluated class pipda.context . ContextSelect ( ) </> Bases pipda.context.ContextBase Context used in a select context In this kind of context, - f.A works as a shortcut of 'A' ; - f[ref] works as a shortcut of ref . However, ref is needed to be evaluated by a context returned by getref Attributes ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , level ) (str) \u2014 Get the ref directly, regardless of data </> getitem ( parent , ref , level ) (any) \u2014 Get the ref directly, which is already evaluated by f[ref] </> method getattr ( parent , ref , level ) \u2192 str </> Get the ref directly, regardless of data method getitem ( parent , ref , level ) \u2192 any </> Get the ref directly, which is already evaluated by f[ref] class pipda.context . ContextEval ( ) </> Bases pipda.context.ContextBase Context used in a data-evaluation context In this kind of context, the expression is evaluated as-is. That is, f.A is evaluated as f.A and f[item] is evaluated as f[item] Attributes ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , level ) (any) \u2014 How to evaluate f.A </> getitem ( parent , ref , level ) (any) \u2014 How to evaluate f[item] </> method getattr ( parent , ref , level ) \u2192 any </> How to evaluate f.A method getitem ( parent , ref , level ) \u2192 any </> How to evaluate f[item] class pipda.context . ContextPending ( ) </> Bases pipda.context.ContextBase Pending context, don't evaluate the expression,awaiting next avaiable context Attributes ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , level ) (str) \u2014 Get the ref directly, regardless of data </> getitem ( parent , ref , level ) (any) \u2014 Get the ref directly, which is already evaluated by f[ref] </> method getattr ( parent , ref , level ) \u2192 str </> Get the ref directly, regardless of data method getitem ( parent , ref , level ) \u2192 any </> Get the ref directly, which is already evaluated by f[ref] class pipda.context . Context ( value , names=None , module=None , qualname=None , type=None , start=1 ) </> Bases enum.Enum Context to solve f.A and f['A'] PENDING: Context to leave the arguments to be evaluated inside the function SELECT: It select-based context EVAL: It evaluation-based context Classes EnumMeta \u2014 Metaclass for Enum </> class enum. EnumMeta ( cls , bases , classdict , **kwds ) </> Metaclass for Enum Attributes __members__ \u2014 Returns a mapping of member name->value. This mapping lists all enum members, including aliases. Note that this is a read-only view of the internal mapping. </> Methods __bool__ ( ) \u2014 classes/types should always be True. </> __call__ ( cls , value , names , module , qualname , type , start ) \u2014 Either returns an existing member, or creates a new enum class. </> __dir__ ( ) \u2014 Specialized dir implementation for types. </> __getattr__ ( cls , name ) \u2014 Return the enum member matching name </> __iter__ ( cls ) \u2014 Returns members in definition order. </> __reversed__ ( cls ) \u2014 Returns members in reverse definition order. </> __setattr__ ( cls , name , value ) \u2014 Block attempts to reassign Enum members. </> method __bool__ ( ) </> classes/types should always be True. staticmethod __call__ ( cls , value , names=None , module=None , qualname=None , type=None , start=1 ) </> Either returns an existing member, or creates a new enum class. This method is used both when an enum class is given a value to match to an enumeration member (i.e. Color(3)) and for the functional API (i.e. Color = Enum('Color', names='RED GREEN BLUE')). When used for the functional API: value will be the name of the new class. names should be either a string of white-space/comma delimited names (values will start at start ), or an iterator/mapping of name, value pairs. module should be set to the module this class is being created in; if it is not set, an attempt to find that module will be made, but if it fails the class will not be picklable. qualname should be set to the actual location this class can be found at in its module; by default it is set to the global scope. If this is not correct, unpickling will fail in some circumstances. type , if set, will be mixed in as the first base class. method __dir__ ( ) </> Specialized dir implementation for types. staticmethod __getattr__ ( cls , name ) </> Return the enum member matching name We use getattr instead of descriptors or inserting into the enum class' dict in order to support name and value being both properties for enum members (which live in the class' dict ) and enum members themselves. staticmethod __iter__ ( cls ) </> Returns members in definition order. staticmethod __reversed__ ( cls ) </> Returns members in reverse definition order. staticmethod __setattr__ ( cls , name , value ) </> Block attempts to reassign Enum members. A simple assignment to the class namespace only changes one of the several possible ways to get an Enum member from the Enum class, resulting in an inconsistent Enumeration.","title":"pipda.context"},{"location":"api/pipda.context/#pipdacontext","text":"</> Provides the context to evaluate f.A and f['A'] By default, 1. in the context of select, both f.A and f['A'] return 'A' 2. in the context of evaluation, f.A returns data.A and f['A'] returns data['A'] 3. when it is pending, you will need to evaluate args and kwargs yourself. Classes ContextError \u2014 Any errors related to contexts </> ContextBase ( ) \u2014 The context abstract class, defining howthe Reference objects are evaluated </> ContextSelect \u2014 Context used in a select context </> ContextEval \u2014 Context used in a data-evaluation context </> ContextPending \u2014 Pending context, don't evaluate the expression,awaiting next avaiable context </> Context \u2014 Context to solve f.A and f['A'] </> class","title":"pipda.context"},{"location":"api/pipda.context/#pipdacontextcontexterror","text":"</> Bases Exception BaseException Any errors related to contexts abstract class","title":"pipda.context.ContextError"},{"location":"api/pipda.context/#pipdacontextcontextbase","text":"</> The context abstract class, defining howthe Reference objects are evaluated getattr defines how f.A is evaluated. Note that f.A.B will always be evaluated as getattr(f.A, 'B') getitem defines how f[item] is evaluated. Note that the item here is an evaluated value defined by getref . ref here defines how the reference/item in f.item is evaluated. Since we could do f[f.A] . Attributes ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , level ) (any) \u2014 Defines how f.A is evaluated </> getitem ( parent , ref , level ) (any) \u2014 Defines how f[item] is evaluated </> abstract method","title":"pipda.context.ContextBase"},{"location":"api/pipda.context/#pipdacontextcontextbasegetattr","text":"</> Defines how f.A is evaluated abstract method","title":"pipda.context.ContextBase.getattr"},{"location":"api/pipda.context/#pipdacontextcontextbasegetitem","text":"</> Defines how f[item] is evaluated class","title":"pipda.context.ContextBase.getitem"},{"location":"api/pipda.context/#pipdacontextcontextselect","text":"</> Bases pipda.context.ContextBase Context used in a select context In this kind of context, - f.A works as a shortcut of 'A' ; - f[ref] works as a shortcut of ref . However, ref is needed to be evaluated by a context returned by getref Attributes ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , level ) (str) \u2014 Get the ref directly, regardless of data </> getitem ( parent , ref , level ) (any) \u2014 Get the ref directly, which is already evaluated by f[ref] </> method","title":"pipda.context.ContextSelect"},{"location":"api/pipda.context/#pipdacontextcontextselectgetattr","text":"</> Get the ref directly, regardless of data method","title":"pipda.context.ContextSelect.getattr"},{"location":"api/pipda.context/#pipdacontextcontextselectgetitem","text":"</> Get the ref directly, which is already evaluated by f[ref] class","title":"pipda.context.ContextSelect.getitem"},{"location":"api/pipda.context/#pipdacontextcontexteval","text":"</> Bases pipda.context.ContextBase Context used in a data-evaluation context In this kind of context, the expression is evaluated as-is. That is, f.A is evaluated as f.A and f[item] is evaluated as f[item] Attributes ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , level ) (any) \u2014 How to evaluate f.A </> getitem ( parent , ref , level ) (any) \u2014 How to evaluate f[item] </> method","title":"pipda.context.ContextEval"},{"location":"api/pipda.context/#pipdacontextcontextevalgetattr","text":"</> How to evaluate f.A method","title":"pipda.context.ContextEval.getattr"},{"location":"api/pipda.context/#pipdacontextcontextevalgetitem","text":"</> How to evaluate f[item] class","title":"pipda.context.ContextEval.getitem"},{"location":"api/pipda.context/#pipdacontextcontextpending","text":"</> Bases pipda.context.ContextBase Pending context, don't evaluate the expression,awaiting next avaiable context Attributes ref ( ContextBase ) \u2014 Defines how item in f[item] is evaluated. This function should return a ContextBase object. </> Methods getattr ( parent , ref , level ) (str) \u2014 Get the ref directly, regardless of data </> getitem ( parent , ref , level ) (any) \u2014 Get the ref directly, which is already evaluated by f[ref] </> method","title":"pipda.context.ContextPending"},{"location":"api/pipda.context/#pipdacontextcontextpendinggetattr","text":"</> Get the ref directly, regardless of data method","title":"pipda.context.ContextPending.getattr"},{"location":"api/pipda.context/#pipdacontextcontextpendinggetitem","text":"</> Get the ref directly, which is already evaluated by f[ref] class","title":"pipda.context.ContextPending.getitem"},{"location":"api/pipda.context/#pipdacontextcontext","text":"</> Bases enum.Enum Context to solve f.A and f['A'] PENDING: Context to leave the arguments to be evaluated inside the function SELECT: It select-based context EVAL: It evaluation-based context Classes EnumMeta \u2014 Metaclass for Enum </> class","title":"pipda.context.Context"},{"location":"api/pipda.context/#enumenummeta","text":"</> Metaclass for Enum Attributes __members__ \u2014 Returns a mapping of member name->value. This mapping lists all enum members, including aliases. Note that this is a read-only view of the internal mapping. </> Methods __bool__ ( ) \u2014 classes/types should always be True. </> __call__ ( cls , value , names , module , qualname , type , start ) \u2014 Either returns an existing member, or creates a new enum class. </> __dir__ ( ) \u2014 Specialized dir implementation for types. </> __getattr__ ( cls , name ) \u2014 Return the enum member matching name </> __iter__ ( cls ) \u2014 Returns members in definition order. </> __reversed__ ( cls ) \u2014 Returns members in reverse definition order. </> __setattr__ ( cls , name , value ) \u2014 Block attempts to reassign Enum members. </> method __bool__ ( ) </> classes/types should always be True. staticmethod __call__ ( cls , value , names=None , module=None , qualname=None , type=None , start=1 ) </> Either returns an existing member, or creates a new enum class. This method is used both when an enum class is given a value to match to an enumeration member (i.e. Color(3)) and for the functional API (i.e. Color = Enum('Color', names='RED GREEN BLUE')). When used for the functional API: value will be the name of the new class. names should be either a string of white-space/comma delimited names (values will start at start ), or an iterator/mapping of name, value pairs. module should be set to the module this class is being created in; if it is not set, an attempt to find that module will be made, but if it fails the class will not be picklable. qualname should be set to the actual location this class can be found at in its module; by default it is set to the global scope. If this is not correct, unpickling will fail in some circumstances. type , if set, will be mixed in as the first base class. method __dir__ ( ) </> Specialized dir implementation for types. staticmethod __getattr__ ( cls , name ) </> Return the enum member matching name We use getattr instead of descriptors or inserting into the enum class' dict in order to support name and value being both properties for enum members (which live in the class' dict ) and enum members themselves. staticmethod __iter__ ( cls ) </> Returns members in definition order. staticmethod __reversed__ ( cls ) </> Returns members in reverse definition order. staticmethod __setattr__ ( cls , name , value ) </> Block attempts to reassign Enum members. A simple assignment to the class namespace only changes one of the several possible ways to get an Enum member from the Enum class, resulting in an inconsistent Enumeration.","title":"enum.EnumMeta"},{"location":"api/pipda.expression/","text":"module pipda . expression </> Provides the abstract class Expression Classes Expression ( ) \u2014 The abstract Expression class </> Functions register_array_ufunc ( func ) \u2014 Register a function to be used as array_ufunc on Expression </> abstract class pipda.expression . Expression ( ) </> The abstract Expression class Methods __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) (FunctionCall) \u2014 Allow numpy ufunc to work on Expression objects </> __getattr__ ( name ) (ReferenceAttr) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) (ReferenceItem) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as index or part of slice </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> __str__ ( ) (str) \u2014 Used for stringify the whole expression </> method __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) \u2192 FunctionCall </> Allow numpy ufunc to work on Expression objects method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 ReferenceAttr </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 ReferenceItem </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as index or part of slice method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs abstract method __str__ ( ) \u2192 str </> Used for stringify the whole expression function pipda.expression . register_array_ufunc ( func ) </> Register a function to be used as array_ufunc on Expression","title":"pipda.expression"},{"location":"api/pipda.expression/#pipdaexpression","text":"</> Provides the abstract class Expression Classes Expression ( ) \u2014 The abstract Expression class </> Functions register_array_ufunc ( func ) \u2014 Register a function to be used as array_ufunc on Expression </> abstract class","title":"pipda.expression"},{"location":"api/pipda.expression/#pipdaexpressionexpression","text":"</> The abstract Expression class Methods __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) (FunctionCall) \u2014 Allow numpy ufunc to work on Expression objects </> __getattr__ ( name ) (ReferenceAttr) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) (ReferenceItem) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as index or part of slice </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> __str__ ( ) (str) \u2014 Used for stringify the whole expression </> method","title":"pipda.expression.Expression"},{"location":"api/pipda.expression/#pipdaexpressionexpressionarray_ufunc","text":"</> Allow numpy ufunc to work on Expression objects method","title":"pipda.expression.Expression.array_ufunc"},{"location":"api/pipda.expression/#pipdaexpressionexpressionhash","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.expression/#pipdaexpressionexpressiongetattr","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.expression/#pipdaexpressionexpressiongetitem","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.expression/#pipdaexpressionexpressionindex","text":"</> Allow Expression object to work as index or part of slice method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.expression/#pipdaexpressionexpressioniter","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs abstract method","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.expression/#pipdaexpressionexpressionstr","text":"</> Used for stringify the whole expression function","title":"pipda.expression.Expression.str"},{"location":"api/pipda.expression/#pipdaexpressionregister_array_ufunc","text":"</> Register a function to be used as array_ufunc on Expression","title":"pipda.expression.register_array_ufunc"},{"location":"api/pipda/","text":"package pipda </> module pipda . reference </> Provides Symbolic and Reference classes Classes Reference ( parent , ref ) \u2014 The Reference class, used to define how it should be evaluatedaccording to the context for references, for example, f.A , f['A'] or the references of them (i.e. f.A.B , f.A['b'] , etc) </> ReferenceAttr \u2014 Attribute references, for example: f.A , f.A.B etc. </> ReferenceItem \u2014 Subscript references, for example: f['A'] , f.A['B'] etc </> module pipda . utils </> Provide utilities Classes PipeableCallCheckWarning \u2014 Warns when checking verb is called normally or using piping </> MultiImplementationsWarning \u2014 Warns when multiple implementations are found </> PipeableCallCheckError \u2014 Raises when checking verb is called normally or using piping </> TypeHolder \u2014 A holder for a type that indicates the function passed toregister_verb or register_func is a placeholder (typically raising NotImplementedError), not a real implementation. </> Functions evaluate_expr ( expr , data , context ) (any) \u2014 Evaluate a mixed expression </> has_expr ( expr ) (bool) \u2014 Check if expr has any Expression object in it </> is_piping ( pipeable , fallback ) (bool) \u2014 Check if the pipeable is called with piping. </> update_user_wrapper ( x , name , qualname , doc , module ) \u2014 Update the wrapper with user specified values </> module pipda . context </> Provides the context to evaluate f.A and f['A'] By default, 1. in the context of select, both f.A and f['A'] return 'A' 2. in the context of evaluation, f.A returns data.A and f['A'] returns data['A'] 3. when it is pending, you will need to evaluate args and kwargs yourself. Classes ContextError \u2014 Any errors related to contexts </> ContextBase ( ) \u2014 The context abstract class, defining howthe Reference objects are evaluated </> ContextSelect \u2014 Context used in a select context </> ContextEval \u2014 Context used in a data-evaluation context </> ContextPending \u2014 Pending context, don't evaluate the expression,awaiting next avaiable context </> Context \u2014 Context to solve f.A and f['A'] </> module pipda . operator </> Provide operators Classes OperatorCall \u2014 The operator call </> Operator \u2014 Defines the operators </> Functions register_operator ( opclass ) \u2014 Register a operator class </> module pipda . expression </> Provides the abstract class Expression Classes Expression ( ) \u2014 The abstract Expression class </> Functions register_array_ufunc ( func ) \u2014 Register a function to be used as array_ufunc on Expression </>","title":"pipda"},{"location":"api/pipda/#pipda","text":"</> module","title":"pipda"},{"location":"api/pipda/#pipdareference","text":"</> Provides Symbolic and Reference classes Classes Reference ( parent , ref ) \u2014 The Reference class, used to define how it should be evaluatedaccording to the context for references, for example, f.A , f['A'] or the references of them (i.e. f.A.B , f.A['b'] , etc) </> ReferenceAttr \u2014 Attribute references, for example: f.A , f.A.B etc. </> ReferenceItem \u2014 Subscript references, for example: f['A'] , f.A['B'] etc </> module","title":"pipda.reference"},{"location":"api/pipda/#pipdautils","text":"</> Provide utilities Classes PipeableCallCheckWarning \u2014 Warns when checking verb is called normally or using piping </> MultiImplementationsWarning \u2014 Warns when multiple implementations are found </> PipeableCallCheckError \u2014 Raises when checking verb is called normally or using piping </> TypeHolder \u2014 A holder for a type that indicates the function passed toregister_verb or register_func is a placeholder (typically raising NotImplementedError), not a real implementation. </> Functions evaluate_expr ( expr , data , context ) (any) \u2014 Evaluate a mixed expression </> has_expr ( expr ) (bool) \u2014 Check if expr has any Expression object in it </> is_piping ( pipeable , fallback ) (bool) \u2014 Check if the pipeable is called with piping. </> update_user_wrapper ( x , name , qualname , doc , module ) \u2014 Update the wrapper with user specified values </> module","title":"pipda.utils"},{"location":"api/pipda/#pipdacontext","text":"</> Provides the context to evaluate f.A and f['A'] By default, 1. in the context of select, both f.A and f['A'] return 'A' 2. in the context of evaluation, f.A returns data.A and f['A'] returns data['A'] 3. when it is pending, you will need to evaluate args and kwargs yourself. Classes ContextError \u2014 Any errors related to contexts </> ContextBase ( ) \u2014 The context abstract class, defining howthe Reference objects are evaluated </> ContextSelect \u2014 Context used in a select context </> ContextEval \u2014 Context used in a data-evaluation context </> ContextPending \u2014 Pending context, don't evaluate the expression,awaiting next avaiable context </> Context \u2014 Context to solve f.A and f['A'] </> module","title":"pipda.context"},{"location":"api/pipda/#pipdaoperator","text":"</> Provide operators Classes OperatorCall \u2014 The operator call </> Operator \u2014 Defines the operators </> Functions register_operator ( opclass ) \u2014 Register a operator class </> module","title":"pipda.operator"},{"location":"api/pipda/#pipdaexpression","text":"</> Provides the abstract class Expression Classes Expression ( ) \u2014 The abstract Expression class </> Functions register_array_ufunc ( func ) \u2014 Register a function to be used as array_ufunc on Expression </>","title":"pipda.expression"},{"location":"api/pipda.operator/","text":"module pipda . operator </> Provide operators Classes OperatorCall \u2014 The operator call </> Operator \u2014 Defines the operators </> Functions register_operator ( opclass ) \u2014 Register a operator class </> class pipda.operator . OperatorCall ( op_func , op_name , *operands ) </> Bases pipda.expression.Expression The operator call Parameters op_func \u2014 The function to handle the call op_name (str) \u2014 The name of the operator Methods __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) (FunctionCall) \u2014 Allow numpy ufunc to work on Expression objects </> __getattr__ ( name ) (ReferenceAttr) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) (ReferenceItem) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as index or part of slice </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> __str__ ( ) \u2014 String representation of the operator call </> method __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) \u2192 FunctionCall </> Allow numpy ufunc to work on Expression objects method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 ReferenceAttr </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 ReferenceItem </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as index or part of slice method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method __str__ ( ) </> String representation of the operator call class pipda.operator . Operator ( ) </> Defines the operators By default, it inherits the operator from the builtin operator library You can define you own operators by subclass this class and decorated it using register_operator . Examples >>> @register_operator >>> class MyOperator ( Operator ): >>> def add ( self , x , y ): >>> return x * y function pipda.operator . register_operator ( opclass ) </> Register a operator class Can be worked as a decorator >>> @register_operator >>> class MyOperator ( Operator ): >>> ... Parameters opclass \u2014 A subclass Returns The opclass","title":"pipda.operator"},{"location":"api/pipda.operator/#pipdaoperator","text":"</> Provide operators Classes OperatorCall \u2014 The operator call </> Operator \u2014 Defines the operators </> Functions register_operator ( opclass ) \u2014 Register a operator class </> class","title":"pipda.operator"},{"location":"api/pipda.operator/#pipdaoperatoroperatorcall","text":"</> Bases pipda.expression.Expression The operator call Parameters op_func \u2014 The function to handle the call op_name (str) \u2014 The name of the operator Methods __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) (FunctionCall) \u2014 Allow numpy ufunc to work on Expression objects </> __getattr__ ( name ) (ReferenceAttr) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) (ReferenceItem) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as index or part of slice </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> __str__ ( ) \u2014 String representation of the operator call </> method","title":"pipda.operator.OperatorCall"},{"location":"api/pipda.operator/#pipdaexpressionexpressionarray_ufunc","text":"</> Allow numpy ufunc to work on Expression objects method","title":"pipda.expression.Expression.array_ufunc"},{"location":"api/pipda.operator/#pipdaexpressionexpressionhash","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.operator/#pipdaexpressionexpressiongetattr","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.operator/#pipdaexpressionexpressiongetitem","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.operator/#pipdaexpressionexpressionindex","text":"</> Allow Expression object to work as index or part of slice method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.operator/#pipdaexpressionexpressioniter","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.operator/#pipdaoperatoroperatorcallstr","text":"</> String representation of the operator call class","title":"pipda.operator.OperatorCall.str"},{"location":"api/pipda.operator/#pipdaoperatoroperator","text":"</> Defines the operators By default, it inherits the operator from the builtin operator library You can define you own operators by subclass this class and decorated it using register_operator . Examples >>> @register_operator >>> class MyOperator ( Operator ): >>> def add ( self , x , y ): >>> return x * y function","title":"pipda.operator.Operator"},{"location":"api/pipda.operator/#pipdaoperatorregister_operator","text":"</> Register a operator class Can be worked as a decorator >>> @register_operator >>> class MyOperator ( Operator ): >>> ... Parameters opclass \u2014 A subclass Returns The opclass","title":"pipda.operator.register_operator"},{"location":"api/pipda.reference/","text":"module pipda . reference </> Provides Symbolic and Reference classes Classes Reference ( parent , ref ) \u2014 The Reference class, used to define how it should be evaluatedaccording to the context for references, for example, f.A , f['A'] or the references of them (i.e. f.A.B , f.A['b'] , etc) </> ReferenceAttr \u2014 Attribute references, for example: f.A , f.A.B etc. </> ReferenceItem \u2014 Subscript references, for example: f['A'] , f.A['B'] etc </> abstract class pipda.reference . Reference ( parent , ref ) </> Bases pipda.expression.Expression The Reference class, used to define how it should be evaluatedaccording to the context for references, for example, f.A , f['A'] or the references of them (i.e. f.A.B , f.A['b'] , etc) Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) (FunctionCall) \u2014 Allow numpy ufunc to work on Expression objects </> __getattr__ ( name ) (ReferenceAttr) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) (ReferenceItem) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as index or part of slice </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> __str__ ( ) (str) \u2014 Used for stringify the whole expression </> method __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) \u2192 FunctionCall </> Allow numpy ufunc to work on Expression objects method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 ReferenceAttr </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 ReferenceItem </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as index or part of slice method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs abstract method __str__ ( ) \u2192 str </> Used for stringify the whole expression class pipda.reference . ReferenceAttr ( parent , ref ) </> Bases pipda.reference.Reference pipda.expression.Expression Attribute references, for example: f.A , f.A.B etc. Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) (FunctionCall) \u2014 Allow numpy ufunc to work on Expression objects </> __getattr__ ( name ) (ReferenceAttr) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) (ReferenceItem) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as index or part of slice </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> __str__ ( ) (str) \u2014 Used for stringify the whole expression </> method __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) \u2192 FunctionCall </> Allow numpy ufunc to work on Expression objects method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 ReferenceAttr </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 ReferenceItem </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as index or part of slice method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method __str__ ( ) \u2192 str </> Used for stringify the whole expression class pipda.reference . ReferenceItem ( parent , ref ) </> Bases pipda.reference.Reference pipda.expression.Expression Subscript references, for example: f['A'] , f.A['B'] etc Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) (FunctionCall) \u2014 Allow numpy ufunc to work on Expression objects </> __getattr__ ( name ) (ReferenceAttr) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) (ReferenceItem) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as index or part of slice </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> __str__ ( ) (str) \u2014 Used for stringify the whole expression </> method __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) \u2192 FunctionCall </> Allow numpy ufunc to work on Expression objects method __hash__ ( ) \u2192 int </> Make it hashable method __getattr__ ( name ) \u2192 ReferenceAttr </> Whenever expr.attr is encountered,return a ReferenceAttr object method __getitem__ ( item ) \u2192 ReferenceItem </> Whenever expr[item] is encountered,return a ReferenceAttr object method __index__ ( ) </> Allow Expression object to work as index or part of slice method __iter__ ( ) </> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method __str__ ( ) \u2192 str </> Used for stringify the whole expression","title":"pipda.reference"},{"location":"api/pipda.reference/#pipdareference","text":"</> Provides Symbolic and Reference classes Classes Reference ( parent , ref ) \u2014 The Reference class, used to define how it should be evaluatedaccording to the context for references, for example, f.A , f['A'] or the references of them (i.e. f.A.B , f.A['b'] , etc) </> ReferenceAttr \u2014 Attribute references, for example: f.A , f.A.B etc. </> ReferenceItem \u2014 Subscript references, for example: f['A'] , f.A['B'] etc </> abstract class","title":"pipda.reference"},{"location":"api/pipda.reference/#pipdareferencereference","text":"</> Bases pipda.expression.Expression The Reference class, used to define how it should be evaluatedaccording to the context for references, for example, f.A , f['A'] or the references of them (i.e. f.A.B , f.A['b'] , etc) Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) (FunctionCall) \u2014 Allow numpy ufunc to work on Expression objects </> __getattr__ ( name ) (ReferenceAttr) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) (ReferenceItem) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as index or part of slice </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> __str__ ( ) (str) \u2014 Used for stringify the whole expression </> method","title":"pipda.reference.Reference"},{"location":"api/pipda.reference/#pipdaexpressionexpressionarray_ufunc","text":"</> Allow numpy ufunc to work on Expression objects method","title":"pipda.expression.Expression.array_ufunc"},{"location":"api/pipda.reference/#pipdaexpressionexpressionhash","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.reference/#pipdaexpressionexpressiongetattr","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.reference/#pipdaexpressionexpressiongetitem","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.reference/#pipdaexpressionexpressionindex","text":"</> Allow Expression object to work as index or part of slice method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.reference/#pipdaexpressionexpressioniter","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs abstract method","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.reference/#pipdaexpressionexpressionstr","text":"</> Used for stringify the whole expression class","title":"pipda.expression.Expression.str"},{"location":"api/pipda.reference/#pipdareferencereferenceattr","text":"</> Bases pipda.reference.Reference pipda.expression.Expression Attribute references, for example: f.A , f.A.B etc. Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) (FunctionCall) \u2014 Allow numpy ufunc to work on Expression objects </> __getattr__ ( name ) (ReferenceAttr) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) (ReferenceItem) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as index or part of slice </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> __str__ ( ) (str) \u2014 Used for stringify the whole expression </> method","title":"pipda.reference.ReferenceAttr"},{"location":"api/pipda.reference/#pipdaexpressionexpressionarray_ufunc_1","text":"</> Allow numpy ufunc to work on Expression objects method","title":"pipda.expression.Expression.array_ufunc"},{"location":"api/pipda.reference/#pipdaexpressionexpressionhash_1","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.reference/#pipdaexpressionexpressiongetattr_1","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.reference/#pipdaexpressionexpressiongetitem_1","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.reference/#pipdaexpressionexpressionindex_1","text":"</> Allow Expression object to work as index or part of slice method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.reference/#pipdaexpressionexpressioniter_1","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.reference/#pipdareferencereferenceattrstr","text":"</> Used for stringify the whole expression class","title":"pipda.reference.ReferenceAttr.str"},{"location":"api/pipda.reference/#pipdareferencereferenceitem","text":"</> Bases pipda.reference.Reference pipda.expression.Expression Subscript references, for example: f['A'] , f.A['B'] etc Parameters parent (any) \u2014 The parent of this reference. For example: f.A for f.A.B ref (any) \u2014 The reference. For example: B for f.A.B Methods __array_ufunc__ ( ufunc , method , *inputs , **kwargs ) (FunctionCall) \u2014 Allow numpy ufunc to work on Expression objects </> __getattr__ ( name ) (ReferenceAttr) \u2014 Whenever expr.attr is encountered,return a ReferenceAttr object </> __getitem__ ( item ) (ReferenceItem) \u2014 Whenever expr[item] is encountered,return a ReferenceAttr object </> __hash__ ( ) (int) \u2014 Make it hashable </> __index__ ( ) \u2014 Allow Expression object to work as index or part of slice </> __iter__ ( ) \u2014 Forbiden iterating on Expression objects </> __str__ ( ) (str) \u2014 Used for stringify the whole expression </> method","title":"pipda.reference.ReferenceItem"},{"location":"api/pipda.reference/#pipdaexpressionexpressionarray_ufunc_2","text":"</> Allow numpy ufunc to work on Expression objects method","title":"pipda.expression.Expression.array_ufunc"},{"location":"api/pipda.reference/#pipdaexpressionexpressionhash_2","text":"</> Make it hashable method","title":"pipda.expression.Expression.hash"},{"location":"api/pipda.reference/#pipdaexpressionexpressiongetattr_2","text":"</> Whenever expr.attr is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getattr"},{"location":"api/pipda.reference/#pipdaexpressionexpressiongetitem_2","text":"</> Whenever expr[item] is encountered,return a ReferenceAttr object method","title":"pipda.expression.Expression.getitem"},{"location":"api/pipda.reference/#pipdaexpressionexpressionindex_2","text":"</> Allow Expression object to work as index or part of slice method","title":"pipda.expression.Expression.index"},{"location":"api/pipda.reference/#pipdaexpressionexpressioniter_2","text":"</> Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs method","title":"pipda.expression.Expression.iter"},{"location":"api/pipda.reference/#pipdareferencereferenceitemstr","text":"</> Used for stringify the whole expression","title":"pipda.reference.ReferenceItem.str"},{"location":"api/pipda.utils/","text":"module pipda . utils </> Provide utilities Classes PipeableCallCheckWarning \u2014 Warns when checking verb is called normally or using piping </> MultiImplementationsWarning \u2014 Warns when multiple implementations are found </> PipeableCallCheckError \u2014 Raises when checking verb is called normally or using piping </> TypeHolder \u2014 A holder for a type that indicates the function passed toregister_verb or register_func is a placeholder (typically raising NotImplementedError), not a real implementation. </> Functions evaluate_expr ( expr , data , context ) (any) \u2014 Evaluate a mixed expression </> has_expr ( expr ) (bool) \u2014 Check if expr has any Expression object in it </> is_piping ( pipeable , fallback ) (bool) \u2014 Check if the pipeable is called with piping. </> update_user_wrapper ( x , name , qualname , doc , module ) \u2014 Update the wrapper with user specified values </> class pipda.utils . PipeableCallCheckWarning ( ) </> Bases Warning Exception BaseException Warns when checking verb is called normally or using piping class pipda.utils . MultiImplementationsWarning ( ) </> Bases Warning Exception BaseException Warns when multiple implementations are found class pipda.utils . PipeableCallCheckError ( ) </> Bases Exception BaseException Raises when checking verb is called normally or using piping class pipda.utils . TypeHolder ( ) </> A holder for a type that indicates the function passed toregister_verb or register_func is a placeholder (typically raising NotImplementedError), not a real implementation. function pipda.utils . update_user_wrapper ( x , name , qualname , doc , module ) </> Update the wrapper with user specified values function pipda.utils . is_piping ( pipeable , fallback ) </> Check if the pipeable is called with piping. Example >>> data >> verb ( ... ) >>> data >>= verb ( ... ) Parameters pipeable (str) \u2014 The name of the verb, used in warning or exception messaging fallback (str) \u2014 What if the AST node fails to retrieve?piping - Suppose this verb is called like data >> verb(...) normal - Suppose this verb is called like verb(data, ...) piping_warning - Suppose piping call, but show a warning normal_warning - Suppose normal call, but show a warning raise - Raise an error Returns (bool) True if it is a piping verb call, otherwise False function pipda.utils . evaluate_expr ( expr , data , context ) \u2192 any </> Evaluate a mixed expression function pipda.utils . has_expr ( expr ) \u2192 bool </> Check if expr has any Expression object in it","title":"pipda.utils"},{"location":"api/pipda.utils/#pipdautils","text":"</> Provide utilities Classes PipeableCallCheckWarning \u2014 Warns when checking verb is called normally or using piping </> MultiImplementationsWarning \u2014 Warns when multiple implementations are found </> PipeableCallCheckError \u2014 Raises when checking verb is called normally or using piping </> TypeHolder \u2014 A holder for a type that indicates the function passed toregister_verb or register_func is a placeholder (typically raising NotImplementedError), not a real implementation. </> Functions evaluate_expr ( expr , data , context ) (any) \u2014 Evaluate a mixed expression </> has_expr ( expr ) (bool) \u2014 Check if expr has any Expression object in it </> is_piping ( pipeable , fallback ) (bool) \u2014 Check if the pipeable is called with piping. </> update_user_wrapper ( x , name , qualname , doc , module ) \u2014 Update the wrapper with user specified values </> class","title":"pipda.utils"},{"location":"api/pipda.utils/#pipdautilspipeablecallcheckwarning","text":"</> Bases Warning Exception BaseException Warns when checking verb is called normally or using piping class","title":"pipda.utils.PipeableCallCheckWarning"},{"location":"api/pipda.utils/#pipdautilsmultiimplementationswarning","text":"</> Bases Warning Exception BaseException Warns when multiple implementations are found class","title":"pipda.utils.MultiImplementationsWarning"},{"location":"api/pipda.utils/#pipdautilspipeablecallcheckerror","text":"</> Bases Exception BaseException Raises when checking verb is called normally or using piping class","title":"pipda.utils.PipeableCallCheckError"},{"location":"api/pipda.utils/#pipdautilstypeholder","text":"</> A holder for a type that indicates the function passed toregister_verb or register_func is a placeholder (typically raising NotImplementedError), not a real implementation. function","title":"pipda.utils.TypeHolder"},{"location":"api/pipda.utils/#pipdautilsupdate_user_wrapper","text":"</> Update the wrapper with user specified values function","title":"pipda.utils.update_user_wrapper"},{"location":"api/pipda.utils/#pipdautilsis_piping","text":"</> Check if the pipeable is called with piping. Example >>> data >> verb ( ... ) >>> data >>= verb ( ... ) Parameters pipeable (str) \u2014 The name of the verb, used in warning or exception messaging fallback (str) \u2014 What if the AST node fails to retrieve?piping - Suppose this verb is called like data >> verb(...) normal - Suppose this verb is called like verb(data, ...) piping_warning - Suppose piping call, but show a warning normal_warning - Suppose normal call, but show a warning raise - Raise an error Returns (bool) True if it is a piping verb call, otherwise False function","title":"pipda.utils.is_piping"},{"location":"api/pipda.utils/#pipdautilsevaluate_expr","text":"</> Evaluate a mixed expression function","title":"pipda.utils.evaluate_expr"},{"location":"api/pipda.utils/#pipdautilshas_expr","text":"</> Check if expr has any Expression object in it","title":"pipda.utils.has_expr"},{"location":"api/source/pipda.context/","text":"SOURCE CODE pipda. context DOCS \"\"\"Provides the context to evaluate f.A and f['A'] By default, 1. in the context of select, both f.A and f['A'] return 'A' 2. in the context of evaluation, f.A returns data.A and f['A'] returns data['A'] 3. when it is pending, you will need to evaluate args and kwargs yourself. \"\"\" from __future__ import annotations from abc import ABC , abstractmethod from enum import Enum from typing import Any , Union class ContextError ( Exception ): DOCS \"\"\"Any errors related to contexts\"\"\" class ContextBase ( ABC ): DOCS \"\"\"The context abstract class, defining how the Reference objects are evaluated - `getattr` defines how `f.A` is evaluated. Note that `f.A.B` will always be evaluated as `getattr(f.A, 'B')` - `getitem` defines how `f[item]` is evaluated. Note that the `item` here is an evaluated value defined by `getref`. - `ref` here defines how the reference/item in `f.item` is evaluated. Since we could do `f[f.A]`. \"\"\" @abstractmethod DOCS def getattr ( self , parent : Any , ref : str , level : int ) -> Any : \"\"\"Defines how `f.A` is evaluated\"\"\" @abstractmethod DOCS def getitem ( self , parent : Any , ref : Any , level : int ) -> Any : \"\"\"Defines how `f[item]` is evaluated\"\"\" @property DOCS def ref ( self ) -> ContextBase : \"\"\"Defines how `item` in `f[item]` is evaluated. This function should return a `ContextBase` object.\"\"\" return self class ContextSelect ( ContextBase ): DOCS \"\"\"Context used in a select context In this kind of context, - `f.A` works as a shortcut of `'A'`; - `f[ref]` works as a shortcut of `ref`. However, `ref` is needed to be evaluated by a context returned by `getref` \"\"\" def getattr ( self , parent : Any , ref : str , level : int ) -> str : DOCS \"\"\"Get the `ref` directly, regardless of `data`\"\"\" return ref def getitem ( self , parent : Any , ref : Any , level : int ) -> Any : DOCS \"\"\"Get the `ref` directly, which is already evaluated by `f[ref]`\"\"\" return ref class ContextEval ( ContextBase ): DOCS \"\"\"Context used in a data-evaluation context In this kind of context, the expression is evaluated as-is. That is, `f.A` is evaluated as `f.A` and `f[item]` is evaluated as `f[item]` \"\"\" def getattr ( self , parent : Any , ref : str , level : int ) -> Any : DOCS \"\"\"How to evaluate `f.A`\"\"\" return getattr ( parent , ref ) def getitem ( self , parent : Any , ref : Any , level : int ) -> Any : DOCS \"\"\"How to evaluate `f[item]`\"\"\" return parent [ ref ] class ContextPending ( ContextBase ): DOCS \"\"\"Pending context, don't evaluate the expression, awaiting next avaiable context\"\"\" def getattr ( self , parent : Any , ref : str , level : int ) -> str : DOCS \"\"\"Get the `ref` directly, regardless of `data`\"\"\" raise ContextError ( \"Pending context cannot be used for evaluation.\" ) def getitem ( self , parent : Any , ref : Any , level : int ) -> Any : DOCS \"\"\"Get the `ref` directly, which is already evaluated by `f[ref]`\"\"\" raise ContextError ( \"Pending context cannot be used for evaluation.\" ) class Context ( Enum ): DOCS \"\"\"Context to solve f.A and f['A'] PENDING: Context to leave the arguments to be evaluated inside the function SELECT: It select-based context EVAL: It evaluation-based context \"\"\" PENDING = ContextPending () SELECT = ContextSelect () EVAL = ContextEval () ContextType = Union [ Context , ContextBase ]","title":"pipda.context"},{"location":"api/source/pipda.expression/","text":"SOURCE CODE pipda. expression DOCS \"\"\"Provides the abstract class Expression\"\"\" from __future__ import annotations from abc import ABC , abstractmethod from functools import partialmethod from typing import TYPE_CHECKING , Any , Callable from .context import ContextBase if TYPE_CHECKING : from .operator import OperatorCall from .function import FunctionCall from .reference import ReferenceAttr , ReferenceItem OPERATORS = { # op, right \"add\" : ( \"+\" , False ), \"radd\" : ( \"+\" , True ), \"sub\" : ( \"-\" , False ), \"rsub\" : ( \"-\" , True ), \"mul\" : ( \"*\" , False ), \"rmul\" : ( \"*\" , True ), \"matmul\" : ( \"@\" , False ), \"rmatmul\" : ( \"@\" , True ), \"truediv\" : ( \"/\" , False ), \"rtruediv\" : ( \"/\" , True ), \"floordiv\" : ( \"//\" , False ), \"rfloordiv\" : ( \"//\" , True ), \"mod\" : ( \"%\" , False ), \"rmod\" : ( \"%\" , True ), \"lshift\" : ( \"<<\" , False ), \"rlshift\" : ( \"<<\" , True ), \"rshift\" : ( \">>\" , False ), \"rrshift\" : ( \">>\" , True ), \"and_\" : ( \"&\" , False ), \"rand_\" : ( \"&\" , True ), \"xor\" : ( \"^\" , False ), \"rxor\" : ( \"^\" , True ), \"or_\" : ( \"|\" , False ), \"ror_\" : ( \"|\" , True ), \"pow\" : ( \"**\" , False ), \"rpow\" : ( \"**\" , True ), \"lt\" : ( \"<\" , False ), \"le\" : ( \"<=\" , False ), \"eq\" : ( \"==\" , False ), \"ne\" : ( \"!=\" , False ), \"gt\" : ( \">\" , False ), \"ge\" : ( \">=\" , False ), \"neg\" : ( \"-\" , False ), \"pos\" : ( \"+\" , False ), \"invert\" : ( \"~\" , False ), } class Expression ( ABC ): DOCS \"\"\"The abstract Expression class\"\"\" _pipda_operator = None def _pipda_array_ufunc ( ufunc : Callable , x : Any , * args : Any , kind : str , ** kwargs : Any , ) -> FunctionCall : \"\"\"Allow numpy array function to work on Expression objects\"\"\" return ufunc ( x , * args , ** kwargs ) def __array_function__ ( self , func , types , args , kwargs ): from .function import FunctionCall return FunctionCall ( self . __class__ . _pipda_array_ufunc , func , * args , kind = \"function\" , ** kwargs , ) def __array_ufunc__ ( DOCS self , ufunc : Callable , method : str , * inputs : Any , ** kwargs : Any , ) -> FunctionCall : \"\"\"Allow numpy ufunc to work on Expression objects\"\"\" from .function import FunctionCall from .piping import PIPING_OPS , PipeableCall if ( ufunc . __name__ == PIPING_OPS [ PipeableCall . PIPING ][ 2 ] and isinstance ( inputs [ 1 ], PipeableCall ) and len ( inputs ) == 2 and method == \"__call__\" ): # We can't patch numpy. # So make # np.ndarray([1, 2]) >> verb() # work return inputs [ 1 ] . _pipda_eval ( inputs [ 0 ]) if method != \"__call__\" : ufunc = getattr ( ufunc , method ) return FunctionCall ( self . __class__ . _pipda_array_ufunc , ufunc , * inputs , kind = \"ufunc\" , ** kwargs , ) def __hash__ ( self ) -> int : DOCS \"\"\"Make it hashable\"\"\" return hash ( id ( self )) def __getattr__ ( self , name : str ) -> ReferenceAttr : DOCS \"\"\"Whenever `expr.attr` is encountered, return a ReferenceAttr object\"\"\" if name . startswith ( \"_pipda_\" ): # Avoid recursion raise AttributeError from .reference import ReferenceAttr return ReferenceAttr ( self , name ) def __getitem__ ( self , item : Any ) -> ReferenceItem : DOCS \"\"\"Whenever `expr[item]` is encountered, return a ReferenceAttr object\"\"\" from .reference import ReferenceItem return ReferenceItem ( self , item ) def _op_method ( self , op : str , * operands : Any ) -> OperatorCall : \"\"\"Handle the operators\"\"\" from .operator import Operator , OperatorCall from .piping import PipeableCall if Expression . _pipda_operator is None : Expression . _pipda_operator = Operator () # Let the verb/pipeable func handle it if ( not OPERATORS [ op ][ 1 ] and OPERATORS . get ( f \"r { op } \" , [ None ])[ 0 ] == PipeableCall . PIPING and isinstance ( operands [ 0 ], PipeableCall ) ): return NotImplemented op_func = getattr ( Expression . _pipda_operator , op ) return OperatorCall ( op_func , op , self , * operands ) # Make sure the operators connect all expressions into one __add__ = partialmethod ( _op_method , \"add\" ) __radd__ = partialmethod ( _op_method , \"radd\" ) __sub__ = partialmethod ( _op_method , \"sub\" ) __rsub__ = partialmethod ( _op_method , \"rsub\" ) __mul__ = partialmethod ( _op_method , \"mul\" ) __rmul__ = partialmethod ( _op_method , \"rmul\" ) __matmul__ = partialmethod ( _op_method , \"matmul\" ) __rmatmul__ = partialmethod ( _op_method , \"rmatmul\" ) __truediv__ = partialmethod ( _op_method , \"truediv\" ) __rtruediv__ = partialmethod ( _op_method , \"rtruediv\" ) __floordiv__ = partialmethod ( _op_method , \"floordiv\" ) __rfloordiv__ = partialmethod ( _op_method , \"rfloordiv\" ) __mod__ = partialmethod ( _op_method , \"mod\" ) __rmod__ = partialmethod ( _op_method , \"rmod\" ) __lshift__ = partialmethod ( _op_method , \"lshift\" ) __rlshift__ = partialmethod ( _op_method , \"rlshift\" ) __rshift__ = partialmethod ( _op_method , \"rshift\" ) __rrshift__ = partialmethod ( _op_method , \"rrshift\" ) __and__ = partialmethod ( _op_method , \"and_\" ) __rand__ = partialmethod ( _op_method , \"rand_\" ) __xor__ = partialmethod ( _op_method , \"xor\" ) __rxor__ = partialmethod ( _op_method , \"rxor\" ) __or__ = partialmethod ( _op_method , \"or_\" ) __ror__ = partialmethod ( _op_method , \"ror_\" ) __pow__ = partialmethod ( _op_method , \"pow\" ) __rpow__ = partialmethod ( _op_method , \"rpow\" ) # __contains__() is forced into bool # __contains__ = partialmethod(_op_method, 'contains') __lt__ = partialmethod ( _op_method , \"lt\" ) __le__ = partialmethod ( _op_method , \"le\" ) __eq__ = partialmethod ( _op_method , \"eq\" ) # type: ignore __ne__ = partialmethod ( _op_method , \"ne\" ) # type: ignore __gt__ = partialmethod ( _op_method , \"gt\" ) __ge__ = partialmethod ( _op_method , \"ge\" ) __neg__ = partialmethod ( _op_method , \"neg\" ) __pos__ = partialmethod ( _op_method , \"pos\" ) __invert__ = partialmethod ( _op_method , \"invert\" ) def __call__ ( self , * args : Any , ** kwargs : Any ) -> Any : from .function import FunctionCall return FunctionCall ( self , * args , ** kwargs ) def __index__ ( self ): DOCS \"\"\"Allow Expression object to work as index or part of slice\"\"\" return None def __iter__ ( self ): DOCS \"\"\"Forbiden iterating on Expression objects If it is happening, probably wrong usage of functions/verbs \"\"\" raise TypeError ( \"An Expression object is possible to be iterable only after \" \"it's evaluated. Do you forget to evalute it or you call it in an \" \"unregistered function?\" ) @abstractmethod DOCS def __str__ ( self ) -> str : \"\"\"Used for stringify the whole expression\"\"\" @abstractmethod def _pipda_eval ( self , data : Any , context : ContextBase = None , ) -> Any : \"\"\"Evaluate the expression using given data\"\"\" def register_array_ufunc ( func : Callable ) -> Callable : DOCS \"\"\"Register a function to be used as __array_ufunc__ on Expression\"\"\" Expression . _pipda_array_ufunc = func # type: ignore return func","title":"pipda.expression"},{"location":"api/source/pipda/","text":"SOURCE CODE pipda DOCS from .context import Context , ContextBase from .expression import Expression , register_array_ufunc from .function import FunctionCall , register_func from .operator import Operator , OperatorCall , register_operator from .reference import ReferenceAttr , ReferenceItem from .symbolic import Symbolic from .utils import evaluate_expr from .verb import VerbCall , register_verb from .piping import register_piping , _patch_default_classes __version__ = \"0.13.1\" register_piping ( \">>\" ) _patch_default_classes ()","title":"pipda"},{"location":"api/source/pipda.operator/","text":"SOURCE CODE pipda. operator DOCS \"\"\"Provide operators\"\"\" from __future__ import annotations import operator from typing import Any , Callable , Type , TYPE_CHECKING from .utils import evaluate_expr from .expression import Expression , OPERATORS if TYPE_CHECKING : from .context import ContextType class OperatorCall ( Expression ): DOCS \"\"\"The operator call Args: op_func: The function to handle the call op_name: The name of the operator operands: The operands of the operator \"\"\" def __init__ ( self , op_func : Callable , op_name : str , * operands : Any ) -> None : self . _pipda_op_func = op_func self . _pipda_op_name = op_name self . _pipda_operands = operands def __str__ ( self ): DOCS \"\"\"String representation of the operator call\"\"\" op , right = OPERATORS [ self . _pipda_op_name ] if right : return f \" { op } \" . join ( reversed ([ str ( operand ) for operand in self . _pipda_operands ]) ) if len ( self . _pipda_operands ) == 1 : return f \" { op }{ str ( self . _pipda_operands [ 0 ]) } \" return f \" { op } \" . join ( str ( operand ) for operand in self . _pipda_operands ) def _pipda_eval ( self , data : Any , context : ContextType = None , ) -> Any : \"\"\"Evaluate the operator call\"\"\" operands = ( evaluate_expr ( arg , data , context ) for arg in self . _pipda_operands ) return self . _pipda_op_func ( * operands ) class Operator : DOCS \"\"\"Defines the operators By default, it inherits the operator from the builtin `operator` library You can define you own operators by subclass this class and decorated it using `register_operator`. Examples: >>> @register_operator >>> class MyOperator(Operator): >>> def add(self, x, y): >>> return x * y \"\"\" def __getattr__ ( self , name : str ) -> Callable : if not OPERATORS [ name ][ 1 ]: # not a right operator (e.g. radd) return getattr ( operator , name ) name = name [ 1 :] return lambda x , y : getattr ( operator , name )( y , x ) def register_operator ( opclass : Type ) -> Type : DOCS \"\"\"Register a operator class Can be worked as a decorator >>> @register_operator >>> class MyOperator(Operator): >>> ... Args: opclass: A subclass Returns: The opclass \"\"\" from .expression import Expression Expression . _pipda_operator = opclass () return opclass","title":"pipda.operator"},{"location":"api/source/pipda.reference/","text":"SOURCE CODE pipda. reference DOCS \"\"\"Provides Symbolic and Reference classes\"\"\" from __future__ import annotations from abc import ABC , abstractmethod from enum import Enum from typing import Any from .utils import evaluate_expr from .context import ContextError , ContextType from .expression import Expression class Reference ( Expression , ABC ): DOCS \"\"\"The Reference class, used to define how it should be evaluated according to the context for references, for example, `f.A`, `f['A']` or the references of them (i.e. `f.A.B`, `f.A['b']`, etc) Args: parent: The parent of this reference. For example: `f.A` for `f.A.B` ref: The reference. For example: `B` for `f.A.B` \"\"\" def __init__ ( self , parent : Any , ref : Any ) -> None : self . _pipda_parent = parent self . _pipda_ref = ref self . _pipda_level = getattr ( self . _pipda_parent , \"_pipda_level\" , 0 ) + 1 @abstractmethod def _pipda_eval ( self , data : Any , context : ContextType = None , ) -> Any : \"\"\"Evaluate the reference according to the context\"\"\" if context is None : # needs context to be evaluated raise ContextError ( f \"Cannot evaluate ` { self . __class__ . __name__ } ` \" \"object without a context.\" ) class ReferenceAttr ( Reference ): DOCS \"\"\"Attribute references, for example: `f.A`, `f.A.B` etc.\"\"\" def __str__ ( self ) -> str : DOCS if self . _pipda_level == 1 : return str ( self . _pipda_ref ) return f \" { self . _pipda_parent } . { self . _pipda_ref } \" def _pipda_eval ( self , data : Any , context : ContextType = None , ) -> Any : \"\"\"Evaluate the attribute references\"\"\" if isinstance ( context , Enum ): context = context . value # if we don't have a context here, assuming that # we are calling `f.a.b(1)`, instead of evaluation super () . _pipda_eval ( data , context ) parent = evaluate_expr ( self . _pipda_parent , data , context ) return context . getattr ( # type: ignore parent , self . _pipda_ref , self . _pipda_level , ) class ReferenceItem ( Reference ): DOCS \"\"\"Subscript references, for example: `f['A']`, `f.A['B']` etc\"\"\" def __str__ ( self ) -> str : DOCS # stringify slice if isinstance ( self . _pipda_ref , slice ): start = self . _pipda_ref . start or \"\" stop = self . _pipda_ref . stop or \"\" step = self . _pipda_ref . step step = \"\" if step is None else f \": { self . _pipda_ref . step } \" ref = f \" { start } : { stop }{ step } \" if self . _pipda_level == 1 : ref = f \"[ { ref } ]\" else : ref = str ( self . _pipda_ref ) if self . _pipda_level == 1 : return ref return f \" { self . _pipda_parent } [ { ref } ]\" def _pipda_eval ( self , data : Any , context : ContextType = None , ) -> Any : \"\"\"Evaluate the subscript references\"\"\" if isinstance ( context , Enum ): context = context . value super () . _pipda_eval ( data , context ) parent = evaluate_expr ( self . _pipda_parent , data , context ) ref = evaluate_expr ( self . _pipda_ref , data , context . ref , # type: ignore ) return context . getitem ( parent , ref , self . _pipda_level ) # type: ignore","title":"pipda.reference"},{"location":"api/source/pipda.utils/","text":"SOURCE CODE pipda. utils DOCS \"\"\"Provide utilities\"\"\" from __future__ import annotations import ast import sys from enum import Enum from functools import singledispatch from typing import Any , Callable import warnings from .context import ContextType DEFAULT_BACKEND = \"_default\" class PipeableCallCheckWarning ( Warning ): DOCS \"\"\"Warns when checking verb is called normally or using piping\"\"\" class MultiImplementationsWarning ( Warning ): DOCS \"\"\"Warns when multiple implementations are found\"\"\" class PipeableCallCheckError ( Exception ): DOCS \"\"\"Raises when checking verb is called normally or using piping\"\"\" class TypeHolder : DOCS \"\"\"A holder for a type that indicates the function passed to register_verb or register_func is a placeholder (typically raising NotImplementedError), not a real implementation. \"\"\" def update_user_wrapper ( DOCS x : Callable , name : str , qualname : str , doc : str , module : str ) -> None : \"\"\"Update the wrapper with user specified values\"\"\" if name : x . __name__ = name if qualname : x . __qualname__ = qualname if doc : x . __doc__ = doc if module : x . __module__ = module def is_piping ( pipeable : str , fallback : str ) -> bool : DOCS \"\"\"Check if the pipeable is called with piping. Example: >>> data >> verb(...) >>> data >>= verb(...) Args: pipeable: The name of the verb, used in warning or exception messaging fallback: What if the AST node fails to retrieve? piping - Suppose this verb is called like `data >> verb(...)` normal - Suppose this verb is called like `verb(data, ...)` piping_warning - Suppose piping call, but show a warning normal_warning - Suppose normal call, but show a warning raise - Raise an error Returns: True if it is a piping verb call, otherwise False \"\"\" from executing import Source from .piping import PIPING_OPS , PipeableCall # Caching? frame = sys . _getframe ( 2 ) node = Source . executing ( frame ) . node if not node : # Using fallbacks if fallback == \"normal\" : return False if fallback == \"piping\" : return True if fallback == \"normal_warning\" : warnings . warn ( f \"Failed to detect AST node calling ` { pipeable } `, \" \"assuming a normal call.\" , PipeableCallCheckWarning , ) return False if fallback == \"piping_warning\" : warnings . warn ( f \"Failed to detect AST node calling ` { pipeable } `, \" \"assuming a piping call.\" , PipeableCallCheckWarning , ) return True raise PipeableCallCheckError ( f \"Failed to detect AST node calling ` { pipeable } ` \" \"without a fallback solution.\" ) try : parent = node . parent except AttributeError : # pragma: no cover return False return ( ( isinstance ( parent , ast . BinOp ) and parent . right is node ) or ( isinstance ( parent , ast . AugAssign ) and parent . value is node ) ) and isinstance ( parent . op , PIPING_OPS [ PipeableCall . PIPING ][ 1 ]) def evaluate_expr ( DOCS expr : Any , data : Any , context : ContextType , ) -> Any : \"\"\"Evaluate a mixed expression\"\"\" if isinstance ( context , Enum ): context = context . value if hasattr ( expr . __class__ , \"_pipda_eval\" ): # Not only for Expression objects, but also # allow customized classes return expr . _pipda_eval ( data , context ) if isinstance ( expr , ( tuple , list , set )): # In case it's subclass return expr . __class__ ( ( evaluate_expr ( elem , data , context ) for elem in expr ) ) if isinstance ( expr , slice ): return slice ( evaluate_expr ( expr . start , data , context ), evaluate_expr ( expr . stop , data , context ), evaluate_expr ( expr . step , data , context ), ) if isinstance ( expr , dict ): return expr . __class__ ( { key : evaluate_expr ( val , data , context ) for key , val in expr . items () } ) return expr @singledispatch DOCS def has_expr ( expr : Any ) -> bool : \"\"\"Check if expr has any Expression object in it\"\"\" from .expression import Expression return isinstance ( expr , Expression ) @has_expr . register ( tuple ) @has_expr . register ( list ) @has_expr . register ( set ) def _ ( expr : Any ) -> Any : return any ( has_expr ( elem ) for elem in expr ) @has_expr . register ( slice ) def _ ( expr : Any ) -> Any : return has_expr (( expr . start , expr . stop , expr . step )) @has_expr . register ( dict ) def _ ( expr : Any ) -> Any : return any ( has_expr ( elem ) for elem in expr . values ())","title":"pipda.utils"}]}